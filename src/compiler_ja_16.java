import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Enumeration;
import java.util.ListResourceBundle;
import java.util.Properties;

public final class compiler_ja_16 extends ListResourceBundle {

	public static void main(String[] args) throws FileNotFoundException,
			IOException {
		// printProp("props/MisakuraMessage.properties");
		printObj();
	}

	public static String kata2hira(String str) {
		StringBuilder sb = new StringBuilder(str);
		for (int i = 0; i < sb.length(); i++) {
			char c = sb.charAt(i);
			if (c >= 'ァ' && c <= 'ン') {
				sb.setCharAt(i, (char) (c - 'ァ' + 'ぁ'));
			} else if (c == 'ヵ') {
				sb.setCharAt(i, 'か');
			} else if (c == 'ヶ') {
				sb.setCharAt(i, 'け');
			} else if (c == 'ヴ') {
				sb.setCharAt(i, 'う');
				sb.insert(i + 1, '゛');
				i++;
			}
		}
		return sb.toString();
	}
	
	public static void printObj() {
		compiler_ja_16 c = new compiler_ja_16();
		Object[][] obj = c.getContents();
		for (Object[] o : obj) {
			String ky = o[0].toString();
			String val = o[1].toString();
			val = val.replaceAll("\n", "<br>");
			System.out.println(ky + "=" + kata2hira(val) + "");
		}
	}

	public static void printProp(String propPath) throws FileNotFoundException,
			IOException {
		Properties properties = new Properties();
		properties.load(new FileInputStream(propPath));
		Enumeration<Object> keys = properties.keys();
		while (keys.hasMoreElements()) {
			String ky = (String) keys.nextElement();
			String vl = (String) properties.get(ky);
			// vl = new String(vl.getBytes(),"");
			String str = ky + "=" + vl;
			System.out.println(str);
		}
	}

	protected final Object[][] getContents() {
		return new Object[][] {
				{ "compiler.err.abstract.cant.be.accessed.directly",
						"抽象 {0} {1} ({2} 内) に直接アクセスすることはできません。" },
				{ "compiler.err.abstract.cant.be.instantiated",
						"{0} は abstract です。インスタンスを生成することはできません。" },
				{ "compiler.err.abstract.meth.cant.have.body",
						"abstract メソッドが本体を持つことはできません。" },
				{ "compiler.err.already.annotated", "{0} {1} は注釈が付いています。" },
				{ "compiler.err.already.defined", "{0} は {1} で定義されています。" },
				{ "compiler.err.already.defined.single.import",
						"{0} は単一の型インポート宣言で定義されています。" },
				{ "compiler.err.already.defined.static.single.import",
						"{0} は static の単一の型インポート宣言で定義されています。" },
				{ "compiler.err.already.defined.this.unit",
						"{0} はコンパイル単位で定義されています。" },
				{ "compiler.err.annotation.missing.default.value",
						"注釈 {0} に {1} がありません。" },
				{ "compiler.err.annotation.not.valid.for.type",
						"注釈はタイプ {0} の値に有効ではありません。" },
				{ "compiler.err.annotation.type.not.applicable",
						"注釈型はこの種類の宣言に使用できません。" },
				{ "compiler.err.annotation.value.must.be.annotation",
						"注釈の値は注釈でなければなりません。" },
				{ "compiler.err.annotation.value.must.be.class.literal",
						"注釈の値はクラスリテラルでなければなりません。" },
				{ "compiler.err.annotation.value.must.be.name.value",
						"注釈の値は ''name=value'' という形式でなければなりません" },
				{ "compiler.err.annotation.value.not.allowable.type",
						"使用できないタイプの注釈の値です。" },
				{ "compiler.err.annotations.not.supported.in.source",
						"注釈は -source {0} でサポートされていません\n(注釈を使用可能にするには、-source 5 以降を使用してください)" },
				{ "compiler.err.anon.class.impl.intf.no.args",
						"名前のないクラスがインタフェースを実装しています。引数を持つことはできません。" },
				{ "compiler.err.anon.class.impl.intf.no.qual.for.new",
						"名前のないクラスがインタフェースを実装しています。new に修飾子を持つことはできません。" },
				{ "compiler.err.anon.class.impl.intf.no.typeargs",
						"名前のないクラスがインタフェースを実装しています。型引数を持つことはできません" },
				{ "compiler.err.array.and.varargs",
						"{2} で {0} と {1} の両方を宣言することはできません" },
				{ "compiler.err.array.dimension.missing", "配列の大きさが指定されていません。" },
				{ "compiler.err.array.req.but.found",
						"配列が要求されましたが、{0} が見つかりました。" },
				{
						"compiler.err.assert.as.identifier",
						"リリース 1.4 から ''assert'' はキーワードなので、識別子として使用することはできません\n(''assert'' を識別子として使用するには、-source 1.3 (またはそれ以前のリリース名) を使用してください)" },
				{ "compiler.err.assignment.from.super-bound",
						"ワイルドカード {0} から代入しています。" },
				{ "compiler.err.assignment.to.extends-bound",
						"ワイルドカード {0} へ代入しています。" },
				{ "compiler.err.attribute.value.must.be.constant",
						"属性の値は定数でなければなりません。" },
				{ "compiler.err.break.outside.switch.loop",
						"break が switch 文またはループの外にあります。" },
				{ "compiler.err.call.must.be.first.stmt.in.ctor",
						"{0} の呼び出しはコンストラクタの先頭文でなければなりません。" },
				{ "compiler.err.call.to.super.not.allowed.in.enum.ctor",
						"列挙型コンストラクタでは、スーパークラスの呼び出しはできません。" },
				{ "compiler.err.cant.access", "{0} にアクセスできません。\n{1}" },
				{ "compiler.err.cant.apply.symbol",
						"{0} ({1} 内) を {2}({3}) に適用できません" },
				{ "compiler.err.cant.apply.symbol.1",
						"{0} ({1} 内) を {2}({3}) に適用できません; {4}" },
				{ "compiler.err.cant.assign.val.to.final.var",
						"final 変数 {0} に値を代入することはできません。" },
				{ "compiler.err.cant.deref", "{0} は間接参照できません。" },
				{ "compiler.err.cant.extend.intf.annotation",
						"@interfaces では ''extends'' は許可されません" },
				{ "compiler.err.cant.inherit.diff.arg",
						"{0} を異なる引数 <{1}> と <{2}> で継承することはできません。" },
				{ "compiler.err.cant.inherit.from.final",
						"final {0} からは継承できません。" },
				{ "compiler.err.cant.read.file", "{0} を読み込めません。" },
				{ "compiler.err.cant.ref.before.ctor.called",
						"スーパータイプのコンストラクタの呼び出し前は {0} を参照できません。" },
				{ "compiler.err.cant.resolve",
						"シンボルを見つけられません。\nシンボル: {0} {3}{1}{2}" },
				{ "compiler.err.cant.resolve.location",
						"シンボルを見つけられません。\nシンボル: {0} {3}{1}{2}\n場所    : {5} の {4}" },
				{ "compiler.err.cant.ret.val.from.meth.decl.void",
						"戻り値の型が void のメソッドからは値を返せません。" },
				{ "compiler.err.cant.select.static.class.from.param.type",
						"パラメータにされた型から static クラスを選択することはできません。" },
				{ "compiler.err.catch.without.try",
						"''catch'' への ''try'' がありません。" },
				{ "compiler.err.clash.with.pkg.of.same.name",
						"{0} は同名のパッケージと競合します。" },
				{ "compiler.err.class.cant.write", "{0} の書き込み中にエラーが発生しました。{1}" },
				{ "compiler.err.class.public.should.be.in.file",
						"クラス {0} は public であり、ファイル {0}.java で宣言しなければなりません。" },
				{ "compiler.err.concrete.inheritance.conflict",
						"{1} のメソッド {0} と {3} の {2} は同じシグニチャーから継承されています。" },
				{ "compiler.err.const.expr.req", "定数式が必要です。" },
				{ "compiler.err.cont.outside.loop", "continue がループの外にあります。" },
				{ "compiler.err.cyclic.annotation.element",
						"注釈の要素タイプがループしています。" },
				{ "compiler.err.cyclic.inheritance", "{0} を含む継承がループしています。" },
				{ "compiler.err.default.allowed.in.intf.annotation.member",
						"デフォルト値は @interface メンバ内でのみ使用できます。" },
				{ "compiler.err.does.not.override.abstract",
						"{0} は abstract でなく、{2} 内の abstract メソッド {1} をオーバーライドしません。" },
				{ "compiler.err.doesnt.exist", "パッケージ {0} は存在しません。" },
				{ "compiler.err.dot.class.expected", "''.class'' がありません。" },
				{ "compiler.err.duplicate.annotation", "注釈が重複しています。" },
				{ "compiler.err.duplicate.annotation.member.value",
						"{1} の注釈メンバの値 {0} が重複しています。" },
				{ "compiler.err.duplicate.case.label", "case ラベルが重複しています。" },
				{ "compiler.err.duplicate.class", "クラス {0} が重複しています。" },
				{ "compiler.err.duplicate.default.label",
						"default ラベルが重複しています。" },
				{ "compiler.err.else.without.if", "''else'' への ''if'' がありません。" },
				{ "compiler.err.empty.char.lit", "空の文字リテラルです。" },
				{ "compiler.err.encl.class.required", "{0} を含む囲うインスタンスが必要です。" },
				{ "compiler.err.enum.annotation.must.be.enum.constant",
						"列挙型注釈値は、列挙型定数でなければなりません。" },
				{
						"compiler.err.enum.as.identifier",
						"リリース 5 から ''enum'' はキーワードなので識別子として使用することはできません\n(''enum'' を識別子として使用するには -source 1.4 またはそれ以前を使用してください)" },
				{ "compiler.err.enum.cant.be.instantiated",
						"列挙型タイプはインスタンス化できません。" },
				{ "compiler.err.enum.const.req", "修飾されていない列挙型定数の名前が必要です。" },
				{ "compiler.err.enum.label.must.be.unqualified.enum",
						"列挙型の switch case ラベルは列挙型定数の非修飾名でなければなりません。" },
				{ "compiler.err.enum.no.finalize",
						"列挙型タイプは finalize メソッドを持つことはできません" },
				{ "compiler.err.enum.no.subclassing",
						"クラスは直接 java.lang.Enum を拡張できません。" },
				{ "compiler.err.enum.types.not.extensible",
						"列挙型タイプは拡張可能ではありません。" },
				{ "compiler.err.enums.must.be.static",
						"列挙型の宣言は static コンテキストでしか使用できません" },
				{ "compiler.err.enums.not.supported.in.source",
						"列挙型は -source {0} でサポートされていません\n(列挙型を使用可能にするには -source 5 以降を使用してください)" },
				{ "compiler.err.error", "エラー:" },
				{ "compiler.err.error.reading.file", "{0} の読み込みエラーです。{1}" },
				{ "compiler.err.except.already.caught",
						"例外 {0} はすでにキャッチされています。" },
				{ "compiler.err.except.never.thrown.in.try",
						"例外 {0} は対応する try 文の本体ではスローされません。" },
				{ "compiler.err.expected", "{0} がありません。" },
				{ "compiler.err.expected2", "{0} または {1} がありません。" },
				{ "compiler.err.expected3", "{0}、{1}、または {2} がありません。" },
				{ "compiler.err.final.parameter.may.not.be.assigned",
						"final パラメータ {0} に値を代入することはできません。" },
				{ "compiler.err.finally.without.try",
						"''finally'' への ''try'' がありません。" },
				{ "compiler.err.foreach.not.applicable.to.type",
						"foreach は式のタイプに使用できません。" },
				{
						"compiler.err.foreach.not.supported.in.source",
						"for-each ループは -source {0} でサポートされていません\n(for-each ループを使用可能にするには、-source 5 以降を使用してください)" },
				{ "compiler.err.fp.number.too.large", "浮動小数点数が大き過ぎます。" },
				{ "compiler.err.fp.number.too.small", "浮動小数点数が小さ過ぎます。" },
				{ "compiler.err.generic.array.creation", "汎用配列を作成します。" },
				{ "compiler.err.generic.throwable",
						"汎用クラスは java.lang.Throwable を拡張できません。" },
				{ "compiler.err.generics.not.supported.in.source",
						"総称型は -source {0} でサポートされていません\n(総称型を使用可能にするには、-source 5 以降を使用してください)" },
				{ "compiler.err.icls.cant.have.static.decl",
						"内部クラスが static 宣言を持つことはできません。" },
				{ "compiler.err.illegal.char", "\\{0} は不正な文字です。" },
				{ "compiler.err.illegal.char.for.encoding",
						"この文字は、エンコーディング {0} にマップできません。" },
				{ "compiler.err.illegal.combination.of.modifiers",
						"修飾子 {0} と {1} の組み合わせは不正です。" },
				{ "compiler.err.illegal.enum.static.ref",
						"初期化子から static フィールドへの参照が不正です。" },
				{ "compiler.err.illegal.esc.char", "エスケープ文字が不正です。" },
				{ "compiler.err.illegal.forward.ref", "順方向参照が不正です。" },
				{ "compiler.err.illegal.generic.type.for.instof",
						"instanceof の総称型が不正です。" },
				{ "compiler.err.illegal.initializer.for.type",
						"{0} の初期化子が不正です。" },
				{ "compiler.err.illegal.line.end.in.char.lit",
						"文字リテラルの行末が不正です。" },
				{ "compiler.err.illegal.nonascii.digit", "不正な非 ASCII 数字です。" },
				{ "compiler.err.illegal.qual.not.icls",
						"修飾子が不正です。{0} は内部クラスではありません。" },
				{ "compiler.err.illegal.start.of.expr", "式の開始が不正です。" },
				{ "compiler.err.illegal.start.of.type", "型の開始が不正です。" },
				{ "compiler.err.illegal.unicode.esc", "Unicode エスケープが不正です。" },
				{ "compiler.err.import.requires.canonical",
						"インポートには {0} の標準名が必要です。" },
				{ "compiler.err.improperly.formed.type.inner.raw.param",
						"型の形式が不適切です。raw 型に指定された型パラメータです。" },
				{ "compiler.err.improperly.formed.type.param.missing",
						"型の形式が不適切です。パラメータが不足しています。" },
				{ "compiler.err.incomparable.types", "型 {0} と {1} は比較できません。" },
				{ "compiler.err.initializer.must.be.able.to.complete.normally",
						"初期化子は正常に完了できなければなりません。" },
				{ "compiler.err.int.number.too.large", "整数 {0} が大き過ぎます。" },
				{ "compiler.err.internal.error.cant.instantiate",
						"内部エラーです。{0} を {1} で ({2}) にインスタンス生成できません。" },
				{ "compiler.err.intf.annotation.cant.have.type.params",
						"@interface が型パラメータを持つことはできません。" },
				{ "compiler.err.intf.annotation.member.clash",
						"@interface メンバーは {1} のメソッド ''{0}'' と競合します" },
				{ "compiler.err.intf.annotation.members.cant.have.params",
						"@interface メンバがパラメータを持つことはできません。" },
				{ "compiler.err.intf.annotation.members.cant.have.type.params",
						"@interface メンバが型パラメータを持つことはできません。" },
				{ "compiler.err.intf.expected.here", "ここにインタフェースが必要です。" },
				{ "compiler.err.intf.meth.cant.have.body",
						"インタフェースメソッドが本体を持つことはできません。" },
				{ "compiler.err.intf.not.allowed.here", "ここではインタフェースは許可されません" },
				{ "compiler.err.invalid.annotation.member.type",
						"注釈メンバの型が不正です。" },
				{ "compiler.err.invalid.hex.number",
						"16 進数には 16 進数字が最低 1 つは含まれていなければなりません。" },
				{ "compiler.err.invalid.meth.decl.ret.type.req",
						"メソッドの宣言が不正です。戻り値の型が必要です。" },
				{ "compiler.err.io.exception", "ソースファイルの読み取りエラーです: {0}" },
				{ "compiler.err.label.already.in.use", "ラベル {0} はすでに使われています。" },
				{ "compiler.err.limit.code", "コードが大きすぎます。" },
				{ "compiler.err.limit.code.too.large.for.try.stmt",
						"try 文のコードが大きすぎます。" },
				{ "compiler.err.limit.dimensions", "配列型の次元が多すぎます。" },
				{ "compiler.err.limit.locals", "ローカル変数が多すぎます。" },
				{ "compiler.err.limit.parameters", "パラメータが多すぎます。" },
				{ "compiler.err.limit.pool", "定数が多すぎます。" },
				{ "compiler.err.limit.pool.in.class", "クラス {0} 内の定数が多すぎます。" },
				{ "compiler.err.limit.stack", "コードが要求するスタックが多すぎます。" },
				{ "compiler.err.limit.string", "定数文字列が長すぎます。" },
				{ "compiler.err.limit.string.overflow",
						"文字列 \"{0}...\" の UTF8 表現が、定数プールに対して長すぎます。" },
				{ "compiler.err.local.enum", "列挙型はローカルではいけません。" },
				{ "compiler.err.local.var.accessed.from.icls.needs.final",
						"ローカル変数 {0} は内部クラスからアクセスされます。final で宣言される必要があります。" },
				{ "compiler.err.malformed.fp.lit", "浮動小数点リテラルが不正です。" },
				{ "compiler.err.method.does.not.override.superclass",
						"メソッドはスーパータイプのメソッドをオーバーライドまたは実装しません" },
				{ "compiler.err.missing.meth.body.or.decl.abstract",
						"メソッド本体がないか、abstract として宣言されています。" },
				{ "compiler.err.missing.ret.stmt", "return 文が指定されていません。" },
				{ "compiler.err.missing.ret.val", "戻り値がありません。" },
				{ "compiler.err.mod.not.allowed.here",
						"修飾子 {0} をここで使うことはできません。" },
				{ "compiler.err.name.clash.same.erasure",
						"名前が競合しています。{0} と {1} は削除後の名前が同じです。" },
				{ "compiler.err.name.clash.same.erasure.no.override",
						"名前が競合しています。{1} の {0} と {3} の {2} はまだ他方をオーバーライドしていませんが、削除後の名前が同じです。" },
				{ "compiler.err.name.reserved.for.internal.use",
						"{0} は内部での使用のため予約されています。" },
				{ "compiler.err.native.meth.cant.have.body",
						"native メソッドが本体を持つことはできません。" },
				{ "compiler.err.neither.conditional.subtype",
						"? に対する互換性のない型 : どちらも他方のサブタイプではありません。\n2 番目のオペランド : {0}\n3 番目のオペランド : {1}" },
				{ "compiler.err.new.not.allowed.in.annotation",
						"''new'' は注釈に使用できません" },
				{ "compiler.err.no.annotation.member", "{1} の注釈メンバ {0} がありません。" },
				{ "compiler.err.no.encl.instance.of.type.in.scope",
						"型 {0} の内部クラスを囲むインスタンスがスコープ内にありません。" },
				{ "compiler.err.no.intf.expected.here", "ここにインタフェースは必要ありません。" },
				{ "compiler.err.no.match.entry",
						"{0} は {1} のエントリに適合しません。{2} が必要です。" },
				{ "compiler.err.no.superclass", "{0} にはスーパークラスがありません。" },
				{ "compiler.err.non-static.cant.be.ref",
						"static でない {0} {1} を static コンテキストから参照することはできません。" },
				{ "compiler.err.not.annotation.type", "{0} は注釈型ではありません。" },
				{ "compiler.err.not.def.access.class.intf.cant.access",
						"{1} の {0} がアクセスできないクラスまたはインタフェースに定義されています" },
				{ "compiler.err.not.def.public.cant.access",
						"{1} の {0} は public ではありません。パッケージ外からはアクセスできません。" },
				{ "compiler.err.not.encl.class", "{0} は内部クラスを囲みません。" },
				{ "compiler.err.not.loop.label", "{0} はループラベルではありません。" },
				{ "compiler.err.not.stmt", "文ではありません。" },
				{ "compiler.err.not.within.bounds", "型パラメータ {0} はその範囲を越えています。" },
				{ "compiler.err.not.within.bounds.explain",
						"型パラメータ {0} はその範囲を越えています。{1}" },
				{ "compiler.err.operator.cant.be.applied",
						"演算子 {0} は {1} に適用できません。" },
				{ "compiler.err.orphaned", "{0} には親がありません。" },
				{ "compiler.err.override.meth", "{0}オーバーライドされたメソッドは {1} です。" },
				{ "compiler.err.override.meth.doesnt.throw",
						"{0}オーバーライドされたメソッドは {1} をスローしません。" },
				{ "compiler.err.override.static",
						"{0}オーバーライドするメソッドが static です。" },
				{ "compiler.err.override.weaker.access",
						"{0}スーパークラスでの定義 ({1}) より弱いアクセス特権を割り当てようとしました。" },
				{ "compiler.err.pkg.annotations.sb.in.package-info.java",
						"パッケージの注釈はファイル package-info.java 内になければなりません。" },
				{ "compiler.err.pkg.clashes.with.class.of.same.name",
						"パッケージ {0} は同名のクラスと競合しています。" },
				{ "compiler.err.premature.eof", "構文解析中にファイルの終わりに移りました" },
				{ "compiler.err.prob.found.req", "{0}\n検出値  : {1}\n期待値  : {2}" },
				{ "compiler.err.prob.found.req.1",
						"{0} {3}\n検出値  : {1}\n期待値  : {2}" },
				{ "compiler.err.proc.bad.config.file",
						"サービス構成ファイルが不正であるか、プロセッサオブジェクトの構築中に例外がスローされました: {0}" },
				{ "compiler.err.proc.cant.access",
						"{0} にアクセスできません\n{1}\n詳細は次のスタックトレースで調査してください。\n{2}" },
				{ "compiler.err.proc.cant.create.loader",
						"注釈プロセッサのクラスローダーを作成できませんでした: {0}" },
				{ "compiler.err.proc.cant.find.class",
						"''{0}'' のクラスファイルが見つかりませんでした。" },
				{ "compiler.err.proc.messager", "{0}" },
				{
						"compiler.err.proc.no.explicit.annotation.processing.requested",
						"クラス名 ''{0}'' が受け入れられるのは、注釈処理が明示的に要求された場合だけです" },
				{ "compiler.err.proc.processor.bad.option.name",
						"プロセッサ ''{1}'' によって指定されたオプション名 ''{0}'' が不正です" },
				{ "compiler.err.proc.processor.cant.instantiate",
						"プロセッサ ''{0}'' のインスタンスをインスタンス化できませんでした" },
				{ "compiler.err.proc.processor.constructor.error",
						"プロセッサオブジェクトの構築中に例外がスローされました: {0}" },
				{ "compiler.err.proc.processor.not.found",
						"注釈プロセッサ ''{0}'' が見つかりません" },
				{ "compiler.err.proc.processor.wrong.type",
						"注釈プロセッサ ''{0}'' が javax.annotation.processing.Processor を実装していません" },
				{ "compiler.err.qualified.new.of.static.class",
						"static クラスの new が修飾されています。" },
				{ "compiler.err.recursive.ctor.invocation",
						"コンストラクタの呼び出しが再帰的です。" },
				{ "compiler.err.ref.ambiguous",
						"{0} の参照はあいまいです。{3} の {1} {2} と {6} の {4} {5} が両方適合します。" },
				{ "compiler.err.repeated.annotation.target",
						"注釈ターゲットが繰り返されています。" },
				{ "compiler.err.repeated.interface", "インタフェースが繰り返されています。" },
				{ "compiler.err.repeated.modifier", "修飾子が繰り返されています。" },
				{ "compiler.err.report.access", "{0} は {2} で {1} アクセスされます。" },
				{ "compiler.err.ret.outside.meth", "メソッドの外の return 文です。" },
				{ "compiler.err.signature.doesnt.match.intf",
						"シグニチャーが {0} に適合しません。互換性のないインタフェースです。" },
				{ "compiler.err.signature.doesnt.match.supertype",
						"シグニチャーが {0} に適合しません。互換性のないスーパータイプです。" },
				{ "compiler.err.source.cant.overwrite.input.file",
						"ソースの書き込みエラーです。入力ファイル {0} を上書きできません。" },
				{ "compiler.err.stack.sim.error",
						"内部エラー: {0} でのスタックシミュレーションエラー" },
				{ "compiler.err.static.imp.only.classes.and.interfaces",
						"static import はクラスとインタフェースからのみとなります。" },
				{
						"compiler.err.static.import.not.supported.in.source",
						"static import 宣言は -source {0} でサポートされていません\n(static import 宣言を使用可能にするには、-source 5 以降を使用してください)" },
				{ "compiler.err.synthetic.name.conflict",
						"シンボル {0} が、{1} でコンパイラが合成したシンボルと競合します。" },
				{ "compiler.err.throws.not.allowed.in.intf.annotation",
						"throws 節を @interface メンバで使用することはできません。" },
				{ "compiler.err.try.without.catch.or.finally",
						"''try'' への ''catch'' または ''finally'' がありません。" },
				{ "compiler.err.type.doesnt.take.params", "型 {0} はパラメータをとりません。" },
				{ "compiler.err.type.found.req",
						"予期しない型\n検出値  : {0}\n期待値  : {1}" },
				{ "compiler.err.type.var.cant.be.deref", "型変数から選択できません。" },
				{ "compiler.err.type.var.may.not.be.followed.by.other.bounds",
						"この型変数の後ろに他の境界を配置することはできません。" },
				{ "compiler.err.type.var.more.than.once",
						"型変数 {0} は {1} の戻り値の型で 2 回以上出現します。インスタンス生成されないままにはできません。" },
				{ "compiler.err.type.var.more.than.once.in.result",
						"型変数 {0} は {1} の型で 2 回以上出現します。インスタンス生成されないままにはできません。" },
				{ "compiler.err.types.incompatible.diff.ret",
						"型 {0} と型 {1} の互換性がありません。両方とも {2} を定義していますが、戻り値の型が無関係です。" },
				{ "compiler.err.unclosed.char.lit", "文字リテラルが閉じられていません。" },
				{ "compiler.err.unclosed.comment", "コメントが閉じられていません。" },
				{ "compiler.err.unclosed.str.lit", "文字列リテラルが閉じられていません。" },
				{ "compiler.err.undef.label", "ラベル {0} は未定義です。" },
				{ "compiler.err.undetermined.type", "{0} の型パラメータを判別できません。" },
				{ "compiler.err.undetermined.type.1",
						"型パラメータ {0} を判別できません; {1}" },
				{ "compiler.err.unexpected.type",
						"予期しない型\n期待値  : {0}\n検出値  : {1}" },
				{ "compiler.err.unknown.enum.constant",
						"クラスファイル {0} 内: 不明な列挙型定数です {1}.{2}" },
				{ "compiler.err.unreachable.stmt", "この文に制御が移ることはありません。" },
				{ "compiler.err.unreported.exception.default.constructor",
						"デフォルトのコンストラクタ内に報告されない例外 {0} が存在します。" },
				{ "compiler.err.unreported.exception.need.to.catch.or.throw",
						"例外 {0} は報告されません。スローするにはキャッチまたは、スロー宣言をしなければなりません。" },
				{ "compiler.err.unsupported.cross.fp.lit",
						"16 進浮動小数点リテラルはこの VM ではサポートされていません。" },
				{ "compiler.err.unsupported.encoding",
						"サポートされていないエンコーディングです: {0}" },
				{ "compiler.err.unsupported.fp.lit",
						"16 進浮動小数点リテラルは -source 5 より前ではサポートされていません" },
				{ "compiler.err.var.might.already.be.assigned",
						"変数 {0} はすでに代入されている可能性があります。" },
				{ "compiler.err.var.might.be.assigned.in.loop",
						"変数 {0} はループ内で代入されている可能性があります。" },
				{ "compiler.err.var.might.not.have.been.initialized",
						"変数 {0} は初期化されていない可能性があります。" },
				{
						"compiler.err.varargs.not.supported.in.source",
						"可変引数メソッドは -source {0} でサポートされていません\n(可変引数メソッドを使用可能にするには、-source 5 以降を使用してください)" },
				{ "compiler.err.void.not.allowed.here",
						"ここで ''void'' 型を使用することはできません。" },
				{ "compiler.err.wrong.number.type.args",
						"型引数の数が不正です。{0} 個必要です。" },
				{ "compiler.misc.anonymous.class", "<anonymous {0}>" },
				{ "compiler.misc.arg.length.mismatch",
						"実引数リストと仮引数リストの長さが異なるため、引数からインスタンスを作成できません。" },
				{ "compiler.misc.assignment.from.super-bound",
						"スーパーバウンド型 {0} からの代入" },
				{ "compiler.misc.assignment.to.extends-bound",
						"拡張バウンド型 {0} への代入" },
				{ "compiler.misc.bad.class.file.header",
						"クラスファイル {0} は不正です。\n{1}\n削除するか、クラスパスの正しいサブディレクトリにあるかを確認してください。" },
				{ "compiler.misc.bad.class.signature", "クラス {0} のシグニチャーが不正です。" },
				{ "compiler.misc.bad.const.pool.tag", "定数プールタグ {0} が不正です。" },
				{ "compiler.misc.bad.const.pool.tag.at",
						"定数プールタグ {1} での {0} が不正です。" },
				{ "compiler.misc.bad.enclosing.method", "囲んでいるメソッド属性が不正です: {0}" },
				{ "compiler.misc.bad.runtime.invisible.param.annotations",
						"RuntimeInvisibleParameterAnnotations 属性が不正です: {0}" },
				{ "compiler.misc.bad.signature", "シグニチャー {0} が不正です。" },
				{ "compiler.misc.base.membership", "すべての基底クラスが、メンバです。" },
				{ "compiler.misc.cant.implement",
						"{1} の {0} は {3} の {2} を実装できません。" },
				{ "compiler.misc.cant.override",
						"{1} の {0} は {3} の {2} をオーバーライドできません。" },
				{ "compiler.misc.ccf.found.later.version",
						"クラスファイル {0} に予想外の新バージョンがあります。" },
				{ "compiler.misc.ccf.unrecognized.attribute",
						"{0} は認識されない属性です。" },
				{ "compiler.misc.clashes.with", "{1} の {0} は {3} の {2} と競合します。" },
				{ "compiler.misc.class.file.not.found", "{0} のクラスファイルが見つかりません" },
				{ "compiler.misc.class.file.wrong.class",
						"クラスファイル {0} に不正なクラスがあります。" },
				{ "compiler.misc.count.error", "エラー {0} 個" },
				{ "compiler.misc.count.error.plural", "エラー {0} 個" },
				{ "compiler.misc.count.warn", "警告 {0} 個" },
				{ "compiler.misc.count.warn.plural", "警告 {0} 個" },
				{ "compiler.misc.fatal.err.cant.locate.ctor",
						"致命的エラー: {0} のコンストラクタを検出できません。" },
				{ "compiler.misc.fatal.err.cant.locate.field",
						"致命的エラー: フィールド {0} を検出できません。" },
				{ "compiler.misc.fatal.err.cant.locate.meth",
						"致命的エラー: メソッド {0} を検出できません。" },
				{ "compiler.misc.fatal.err.no.java.lang",
						"致命的エラー: クラスパスまたはブートクラスパスでパッケージ java.lang を検出できません。" },
				{ "compiler.misc.file.does.not.contain.package",
						"ファイルにパッケージ {0} が含まれていません" },
				{ "compiler.misc.file.doesnt.contain.class",
						"ファイルにクラス {0} が含まれていません。" },
				{ "compiler.misc.illegal.start.of.class.file",
						"クラスファイルの開始が不正です。" },
				{ "compiler.misc.incompatible.types", "互換性のない型" },
				{ "compiler.misc.incompatible.types.1", "互換性のない型; {0}" },
				{ "compiler.misc.inconvertible.types", "変換できない型" },
				{ "compiler.misc.inferred.do.not.conform.to.bounds",
						"推定型引数 {0} は型変数 {1} の境界に適合しません。" },
				{ "compiler.misc.kindname", "識別子 ({0})" },
				{ "compiler.misc.kindname.annotation", "@インタフェース" },
				{ "compiler.misc.kindname.class", "クラス" },
				{ "compiler.misc.kindname.class.package", "クラス、パッケージ" },
				{ "compiler.misc.kindname.constructor", "コンストラクタ" },
				{ "compiler.misc.kindname.interface", "インタフェース" },
				{ "compiler.misc.kindname.method", "メソッド" },
				{ "compiler.misc.kindname.method.class", "メソッド、クラス" },
				{ "compiler.misc.kindname.method.class.package",
						"メソッド、クラス、パッケージ" },
				{ "compiler.misc.kindname.method.package", "メソッド、パッケージ" },
				{ "compiler.misc.kindname.package", "パッケージ" },
				{ "compiler.misc.kindname.static", "static" },
				{ "compiler.misc.kindname.type.variable", "型変数の境界" },
				{ "compiler.misc.kindname.value", "値" },
				{ "compiler.misc.kindname.value.class", "値、クラス" },
				{ "compiler.misc.kindname.value.class.package", "値、クラス、パッケージ" },
				{ "compiler.misc.kindname.value.method", "値、メソッド" },
				{ "compiler.misc.kindname.value.method.class", "値、メソッド、クラス" },
				{ "compiler.misc.kindname.value.method.class.package",
						"値、メソッド、クラス、パッケージ" },
				{ "compiler.misc.kindname.value.method.package", "値、メソッド、パッケージ" },
				{ "compiler.misc.kindname.value.package", "値、パッケージ" },
				{ "compiler.misc.kindname.variable", "変数" },
				{ "compiler.misc.kindname.variable.class", "変数、クラス" },
				{ "compiler.misc.kindname.variable.class.package",
						"変数、クラス、パッケージ" },
				{ "compiler.misc.kindname.variable.method", "変数、メソッド" },
				{ "compiler.misc.kindname.variable.method.class", "変数、メソッド、クラス" },
				{ "compiler.misc.kindname.variable.method.class.package",
						"変数、メソッド、クラス、パッケージ" },
				{ "compiler.misc.kindname.variable.method.package",
						"変数、メソッド、パッケージ" },
				{ "compiler.misc.kindname.variable.package", "変数、パッケージ" },
				{ "compiler.misc.no.conforming.assignment.exists",
						"型変数 {0} のインスタンスが存在しないので、引数型 {1} は仮パラメータ型 {2} に適合しません。" },
				{ "compiler.misc.no.conforming.instance.exists",
						"型変数 {0} のインスタンスが存在しないので、{1} は {2} に適合しません。" },
				{ "compiler.misc.no.unique.maximal.instance.exists",
						"型変数 {0} (上限 {1}) の固有の最大インスタンスが存在しません。" },
				{ "compiler.misc.no.unique.minimal.instance.exists",
						"型変数 {0} (下限 {1}) の固有の最小インスタンスが存在しません。" },
				{ "compiler.misc.override.incompatible.ret",
						"{0}互換性のない戻り値の型を使おうとしました。" },
				{ "compiler.misc.override.unchecked.ret",
						"{0}; 戻り値の型は無検査変換が必要です。" },
				{ "compiler.misc.possible.loss.of.precision", "精度が落ちている可能性" },
				{ "compiler.misc.resume.abort", "R)再開, A)中止>" },
				{ "compiler.misc.source.unavailable", "(ソースが利用不可)" },
				{ "compiler.misc.token.bad-symbol", "<bad symbol>" },
				{ "compiler.misc.token.character", "<character>" },
				{ "compiler.misc.token.double", "<double>" },
				{ "compiler.misc.token.end-of-input", "<end of input>" },
				{ "compiler.misc.token.float", "<float>" },
				{ "compiler.misc.token.identifier", "<identifier>" },
				{ "compiler.misc.token.integer", "<integer>" },
				{ "compiler.misc.token.long-integer", "<long integer>" },
				{ "compiler.misc.token.string", "<string>" },
				{ "compiler.misc.type.parameter", "型パラメータ {0} " },
				{ "compiler.misc.type.req.class", "クラス" },
				{ "compiler.misc.type.req.class.array", "クラスまたは配列" },
				{ "compiler.misc.type.req.exact", "境界のないクラスまたはインタフェース" },
				{ "compiler.misc.type.req.ref", "参照" },
				{ "compiler.misc.unable.to.access.file",
						"ファイル {0} にアクセスすることができません。" },
				{ "compiler.misc.unchecked.assign", "[unchecked] 無検査変換です" },
				{ "compiler.misc.unchecked.cast.to.type",
						"[unchecked] 無検査キャストです" },
				{ "compiler.misc.unchecked.clash.with",
						"{1} の {0} は {3} の {2} をオーバーライドします。" },
				{ "compiler.misc.unchecked.implement",
						"{1} の {0} は {3} の {2} を実装します。" },
				{ "compiler.misc.unchecked.override",
						"{1} の {0} は {3} の {2} を上書きします。" },
				{ "compiler.misc.undecl.type.var", "型変数 {0} は宣言されていません。" },
				{ "compiler.misc.undetermined.type", "未定型" },
				{ "compiler.misc.unicode.str.not.supported",
						"クラスファイル内の Unicode 文字列はサポートされていません。" },
				{ "compiler.misc.varargs.clash.with",
						"{1} の {0} は {3} の {2} を上書きします。" },
				{ "compiler.misc.varargs.implement",
						"{1} の {0} は {3} の {2} を実装します。" },
				{ "compiler.misc.varargs.override",
						"{1} の {0} は {3} の {2} を上書きします。" },
				{ "compiler.misc.verbose.checking.attribution", "[{0} を確認中]" },
				{ "compiler.misc.verbose.classpath", "[クラスファイルの検索パス: {0}]" },
				{ "compiler.misc.verbose.loading", "[{0} を読み込み中]" },
				{ "compiler.misc.verbose.parsing.done", "[{0}ms で構文解析完了]" },
				{ "compiler.misc.verbose.parsing.started", "[{0} を構文解析開始]" },
				{ "compiler.misc.verbose.retro", "[{0} を組み替え中]" },
				{ "compiler.misc.verbose.retro.with", "{0} を {1} で組み替え中です。" },
				{ "compiler.misc.verbose.retro.with.list",
						"{0} を型パラメータ {1}、スーパータイプ {2}、インタフェース {3} で組み替え中です。" },
				{ "compiler.misc.verbose.sourcepath", "[ソースファイルの検索パス: {0}]" },
				{ "compiler.misc.verbose.total", "[合計 {0}ms]" },
				{ "compiler.misc.verbose.wrote.file", "[{0} を書き込み完了]" },
				{ "compiler.misc.wrong.version",
						"クラスファイルのバージョン {0}.{1} は不正です。{2}.{3} であるべきです。" },
				{ "compiler.misc.x.print.processor.info",
						"プロセッサ {0} は {1} に一致し、{2} を返します。" },
				{ "compiler.misc.x.print.rounds",
						"往復 {0}:\n\t入力ファイル: {1}\n\t注釈: {2}\n\t最後の往復: {3}" },
				{ "compiler.note.deprecated.filename",
						"{0} は推奨されない API を使用またはオーバーライドしています。" },
				{ "compiler.note.deprecated.filename.additional",
						"{0} に推奨されない API の追加使用またはオーバーライドがあります。" },
				{ "compiler.note.deprecated.plural",
						"一部の入力ファイルは推奨されない API を使用またはオーバーライドしています。" },
				{ "compiler.note.deprecated.plural.additional",
						"一部の入力ファイルは推奨されない API を追加使用またはオーバーライドしています。" },
				{ "compiler.note.deprecated.recompile",
						"詳細については、-Xlint:deprecation オプションを指定して再コンパイルしてください。" },
				{ "compiler.note.note", "注:" },
				{ "compiler.note.proc.messager", "{0}" },
				{ "compiler.note.unchecked.filename",
						"{0} の操作は、未チェックまたは安全ではありません。" },
				{ "compiler.note.unchecked.filename.additional",
						"{0} に未チェックまたは安全ではない操作がさらにあります。" },
				{ "compiler.note.unchecked.plural",
						"入力ファイルの操作のうち、未チェックまたは安全ではないものがあります。" },
				{ "compiler.note.unchecked.plural.additional",
						"入力ファイルの操作のうち、未チェックまたは安全ではないものがさらにあります。" },
				{ "compiler.note.unchecked.recompile",
						"詳細については、-Xlint:unchecked オプションを指定して再コンパイルしてください。" },
				{ "compiler.warn.annotation.method.not.found",
						"タイプ ''{0}'' 内に注釈メソッド ''{1}()'' が見つかりません" },
				{ "compiler.warn.annotation.method.not.found.reason",
						"タイプ ''{0}'' 内に注釈メソッド ''{1}()'' が見つかりません: {2}" },
				{
						"compiler.warn.assert.as.identifier",
						"リリース 1.4 から ''assert'' はキーワードなので、識別子として使用することはできません\n(''assert'' をキーワードとして使用するには、-source 1.4 (またはそれ以降のリリース名) を使用してください)" },
				{
						"compiler.warn.big.major.version",
						"{0}: メジャーバージョン {1} は、このコンパイラでサポートされている最新のメジャーバージョン {2} より新しいです。\nコンパイラのアップグレードをお勧めします。" },
				{ "compiler.warn.constant.SVUID",
						"[serial] serialVersionUID はクラス {0} の定数でなければなりません。" },
				{ "compiler.warn.dir.path.element.not.found",
						"[path] 不正なパス要素 \"{0}\": そのディレクトリは存在しません。" },
				{ "compiler.warn.div.zero", "[divzero] ゼロで除算" },
				{ "compiler.warn.empty.if", "[empty] if 以降が空の文です" },
				{
						"compiler.warn.enum.as.identifier",
						"リリース 5 から ''enum'' はキーワードなので識別子として使用することはできません\n(''enum'' をキーワードとして使用するには -source 5 以降を使用してください)" },
				{ "compiler.warn.finally.cannot.complete",
						"[finally] finally 節が正常に完了できません。" },
				{ "compiler.warn.forward.ref", "初期化される前の変数 ''{0}'' を参照しようとしました" },
				{ "compiler.warn.has.been.deprecated",
						"[deprecation] {1} の {0} は推奨されません。" },
				{ "compiler.warn.illegal.char.for.encoding",
						"この文字は、エンコーディング {0} にマップできません。" },
				{ "compiler.warn.improper.SVUID",
						"[serial] serialVersionUID は、クラス {0} に static ファイナルを宣言する必要があります。" },
				{
						"compiler.warn.inexact.non-varargs.call",
						"最終パラメータの不正確な引数型を持った可変引数メソッドの非可変引数呼び出し;\n可変引数呼び出しに関しては {0} にキャストします。\n非可変引数呼び出しに関しては {1} にキャストしてこの警告を出さないようにします。" },
				{ "compiler.warn.invalid.archive.file",
						"[path] パス上の予期しないファイル: {0}" },
				{ "compiler.warn.long.SVUID",
						"[serial] serialVersionUID は、クラス {0} の long 型でなければなりません。" },
				{ "compiler.warn.missing.SVUID",
						"[serial] 直列化可能なクラス {0} には、serialVersionUID が定義されていません。" },
				{ "compiler.warn.missing.deprecated.annotation",
						"[dep-ann] 推奨されない項目は @Deprecated で注釈が付けられていません。" },
				{ "compiler.warn.override.bridge",
						"{0}; オーバーライドされたメソッドはブリッジメソッドです。" },
				{ "compiler.warn.override.varargs.extra",
						"{0}; オーバーライドしているメソッドには ''...'' がありません。" },
				{ "compiler.warn.override.varargs.missing",
						"{0}; オーバーライドされたメソッドには ''...'' がありません。" },
				{ "compiler.warn.path.element.not.found",
						"[path] 不正なパス要素 \"{0}\": そのファイルまたはディレクトリはありません。" },
				{ "compiler.warn.pkg-info.already.seen",
						"[package-info] package-info.java ファイルがすでにパッケージ {0} 用に表示されています。" },
				{ "compiler.warn.position.overflow",
						"位置エンコーディングが行 {0} でオーバーフローします" },
				{ "compiler.warn.possible.fall-through.into.case",
						"[fallthrough] case に fall-through する可能性があります。" },
				{ "compiler.warn.prob.found.req", "{0}\n検出値  : {1}\n期待値  : {2}" },
				{ "compiler.warn.proc.annotations.without.processors",
						"これらの注釈を要求するプロセッサはありませんでした: {0}" },
				{ "compiler.warn.proc.file.create.last.round",
						"最後に作成されたタイプ ''{0}'' のファイルは注釈処理に渡されません。" },
				{ "compiler.warn.proc.file.reopening",
						"''{0}'' 用のファイルを複数回作成しようとしています" },
				{ "compiler.warn.proc.illegal.file.name",
						"無効な名前 ''{0}'' のファイルは作成できません。" },
				{ "compiler.warn.proc.malformed.supported.string",
						"プロセッサ ''{1}'' が返したサポートされる注釈型の文字列 ''{0}'' が不正です" },
				{ "compiler.warn.proc.messager", "{0}" },
				{ "compiler.warn.proc.package.does.not.exist",
						"パッケージ {0} は存在しません" },
				{ "compiler.warn.proc.proc-only.requested.no.procs",
						"コンパイルなしの注釈処理が要求されましたが、プロセッサが見つかりませんでした。" },
				{ "compiler.warn.proc.processor.incompatible.source.version",
						"注釈プロセッサ ''{1}'' から -source ''{2}'' より小さいソースバージョン ''{0}'' がサポートされています" },
				{ "compiler.warn.proc.type.already.exists",
						"タイプ ''{0}'' のファイルは既にソースパスもしくはクラスパスに存在します" },
				{ "compiler.warn.proc.type.recreate",
						"タイプ ''{0}'' のファイルを複数回作成しようとしています" },
				{ "compiler.warn.proc.unclosed.type.files",
						"タイプ ''{0}'' のファイルが閉じられていません。これらのタイプは注釈処理されません" },
				{ "compiler.warn.proc.unmatched.processor.options",
						"次のオプションはどのプロセッサでも認識されませんでした: ''{0}''" },
				{ "compiler.warn.proc.use.implicit",
						"暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-implicit を使用し暗黙的コンパイルのポリシーを指定して下さい。" },
				{
						"compiler.warn.proc.use.proc.or.implicit",
						"暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-proc:none を使用し注釈処理を無効にするか -implicit を使用し暗黙的コンパイルのポリシーを指定して下さい。" },
				{ "compiler.warn.redundant.cast", "[cast] {0} への冗長なキャストです" },
				{ "compiler.warn.sun.proprietary",
						"{0} は Sun が所有する API であり、今後のリリースで削除される可能性があります。" },
				{ "compiler.warn.unchecked.assign",
						"[unchecked] {0} から {1} への無検査代入です。" },
				{ "compiler.warn.unchecked.assign.to.var",
						"[unchecked] raw 型 {1} のメンバーとして変数 {0} への無検査代入です。" },
				{ "compiler.warn.unchecked.call.mbr.of.raw.type",
						"[unchecked] raw 型 {1} のメンバとしての {0} への無検査呼び出しです。" },
				{ "compiler.warn.unchecked.cast.to.type",
						"[unchecked] 型 {0} への無検査キャストです。" },
				{ "compiler.warn.unchecked.generic.array.creation",
						"[unchecked] 可変引数パラメータに対する型 {0} の総称型配列の無検査作成です。" },
				{ "compiler.warn.unchecked.meth.invocation.applied",
						"[unchecked] 無検査メソッド呼び出し: {1} の {0} は {2}({3}) に適用されます。" },
				{ "compiler.warn.unexpected.archive.file",
						"[path] アーカイブファイルの予期しない拡張子: {0}" },
				{ "compiler.warn.warning", "警告:" },
				{ "ncompiler.misc.type.variable.has.undetermined.type",
						"型変数 {0} は未定型です。" } };
	}
}