import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Enumeration;
import java.util.ListResourceBundle;
import java.util.Properties;

public final class compiler_ja_17 extends ListResourceBundle {

	public static void main(String[] args) throws FileNotFoundException,
			IOException {
		// printProp("props/MisakuraMessage.properties");
		printObj();
		// System.out.println(System.getProperty("java.version"));
	}

	public static void printObj() {
		compiler_ja_17 c = new compiler_ja_17();
		Object[][] obj = c.getContents();
		for (Object[] o : obj) {
			String ky = o[0].toString();
			String val = o[1].toString();
			val = val.replaceAll("\n", "<br>");
			System.out.println(ky + "=" + val + "");
		}
	}

	public static void printProp(String propPath) throws FileNotFoundException,
			IOException {
		Properties properties = new Properties();
		properties.load(new FileInputStream(propPath));
		Enumeration<Object> keys = properties.keys();
		while (keys.hasMoreElements()) {
			String ky = (String) keys.nextElement();
			String vl = (String) properties.get(ky);
			// vl = new String(vl.getBytes(),"");
			String str = ky + "=" + vl;
			System.out.println(str);
		}
	}

	protected final Object[][] getContents() {
		return new Object[][] {
				{ "compiler.err.abstract.cant.be.accessed.directly",
						"抽象{0}である{1}({2}内)に直接アクセスすることはできません" },
				{ "compiler.err.abstract.cant.be.instantiated",
						"{0}はabstractです。インスタンスを生成することはできません" },
				{ "compiler.err.abstract.meth.cant.have.body",
						"abstractメソッドが本体を持つことはできません" },
				{ "compiler.err.already.annotated", "{0} {1}は注釈が付いています" },
				{ "compiler.err.already.defined", "{0} {1}はすでに{2} {3}で定義されています" },
				{ "compiler.err.already.defined.in.clinit",
						"{0} {1}はすでに{3} {4}の{2}で定義されています" },
				{ "compiler.err.already.defined.single.import",
						"{0}は単一の型インポート宣言で定義されています" },
				{ "compiler.err.already.defined.static.single.import",
						"{0}はstaticの単一の型インポート宣言で定義されています" },
				{ "compiler.err.already.defined.this.unit",
						"{0}はコンパイル単位で定義されています" },
				{ "compiler.err.annotation.missing.default.value",
						"注釈{0}には属性{1}の値がありません" },
				{ "compiler.err.annotation.missing.default.value.1",
						"注釈{0}には属性{1}の値がありません" },
				{ "compiler.err.annotation.not.valid.for.type",
						"注釈は型{0}の値に有効ではありません" },
				{ "compiler.err.annotation.type.not.applicable",
						"注釈型はこの種類の宣言に使用できません" },
				{ "compiler.err.annotation.value.must.be.annotation",
						"注釈の値は注釈である必要があります" },
				{ "compiler.err.annotation.value.must.be.class.literal",
						"注釈の値はクラス・リテラルである必要があります" },
				{ "compiler.err.annotation.value.must.be.name.value",
						"注釈の値は''name=value''という形式である必要があります" },
				{ "compiler.err.annotation.value.not.allowable.type",
						"使用できない型の注釈の値です" },
				{ "compiler.err.annotations.not.supported.in.source",
						"注釈は-source {0}でサポートされていません\n(注釈を使用可能にするには、-source 5以降を使用してください)" },
				{ "compiler.err.anon.class.impl.intf.no.args",
						"名前のないクラスがインタフェースを実装しています。引数を持つことはできません" },
				{ "compiler.err.anon.class.impl.intf.no.qual.for.new",
						"名前のないクラスがインタフェースを実装しています。newに修飾子を持つことはできません。" },
				{ "compiler.err.anon.class.impl.intf.no.typeargs",
						"名前のないクラスがインタフェースを実装しています。型引数を持つことはできません" },
				{ "compiler.err.array.and.varargs",
						"{2}で{0}と{1}の両方を宣言することはできません" },
				{ "compiler.err.array.dimension.missing", "配列の大きさが指定されていません" },
				{ "compiler.err.array.req.but.found", "配列が要求されましたが、{0}が見つかりました" },
				{
						"compiler.err.assert.as.identifier",
						"リリース1.4から''assert''はキーワードなので、識別子として使用することはできません\n(''assert''を識別子として使用するには、-source 1.3以前を使用してください)" },
				{ "compiler.err.assignment.from.super-bound",
						"ワイルドカード{0}から代入しています" },
				{ "compiler.err.assignment.to.extends-bound",
						"ワイルドカード{0}へ代入しています" },
				{ "compiler.err.attribute.value.must.be.constant",
						"属性の値は定数である必要があります" },
				{ "compiler.err.break.outside.switch.loop",
						"breakがswitch文またはループの外にあります" },
				{ "compiler.err.call.must.be.first.stmt.in.ctor",
						"{0}の呼出しはコンストラクタの先頭文である必要があります" },
				{ "compiler.err.call.to.super.not.allowed.in.enum.ctor",
						"列挙型コンストラクタでは、スーパークラスの呼出しはできません" },
				{ "compiler.err.cannot.create.array.with.diamond",
						"''<>''を持つ配列は作成できません" },
				{ "compiler.err.cannot.create.array.with.type.arguments",
						"型引数を持つ配列を作成できません" },
				{ "compiler.err.cant.access", "{0}にアクセスできません\n{1}" },
				{ "compiler.err.cant.apply.diamond", "{0}の型引数を推定できません" },
				{ "compiler.err.cant.apply.diamond.1",
						"{0}の型引数を推定できません。\n理由: {1}" },
				{ "compiler.err.cant.apply.symbol",
						"{4} {5}の{0} {1}は指定された型に適用できません\n期待値: {2}\n検出値: {3}" },
				{ "compiler.err.cant.apply.symbol.1",
						"{4} {5}の{0} {1}は指定された型に適用できません。\n期待値: {2}\n検出値: {3}\n理由: {6}" },
				{ "compiler.err.cant.apply.symbols", "{1}に適切な{0}が見つかりません({2})" },
				{ "compiler.err.cant.assign.val.to.final.var",
						"final変数{0}に値を代入することはできません" },
				{ "compiler.err.cant.deref", "{0}は間接参照できません" },
				{ "compiler.err.cant.extend.intf.annotation",
						"@interfacesでは''extends''は許可されません" },
				{ "compiler.err.cant.inherit.diff.arg",
						"{0}を異なる引数<{1}>と<{2}>で継承することはできません" },
				{ "compiler.err.cant.inherit.from.final", "final {0}からは継承できません" },
				{ "compiler.err.cant.read.file", "{0}を読み込めません" },
				{ "compiler.err.cant.ref.before.ctor.called",
						"スーパータイプのコンストラクタの呼出し前は{0}を参照できません" },
				{ "compiler.err.cant.resolve", "シンボルを見つけられません\nシンボル: {0} {1}" },
				{ "compiler.err.cant.resolve.args",
						"シンボルを見つけられません\nシンボル: {0} {1}({3})" },
				{ "compiler.err.cant.resolve.args.params",
						"シンボルを見つけられません\nシンボル: {0} <{2}>{1}({3})" },
				{ "compiler.err.cant.resolve.location",
						"シンボルを見つけられません\nシンボル:   {0} {1}\n場所: {4}" },
				{ "compiler.err.cant.resolve.location.args",
						"シンボルを見つけられません\nシンボル:   {0} {1}({3})\n場所: {4}" },
				{ "compiler.err.cant.resolve.location.args.params",
						"シンボルを見つけられません\nシンボル:   {0} <{2}>{1}({3})\n場所: {4}" },
				{ "compiler.err.cant.ret.val.from.meth.decl.void",
						"戻り値の型がvoidのメソッドからは値を返せません" },
				{ "compiler.err.cant.select.static.class.from.param.type",
						"パラメータにされた型からstaticクラスを選択することはできません" },
				{ "compiler.err.catch.without.try", "''catch''への''try''がありません" },
				{ "compiler.err.clash.with.pkg.of.same.name",
						"{0} {1}は同名のパッケージと競合します" },
				{ "compiler.err.class.cant.write", "{0}の書込み中にエラーが発生しました: {1}" },
				{ "compiler.err.class.public.should.be.in.file",
						"クラス{0}はpublicであり、ファイル{0}.javaで宣言する必要があります" },
				{ "compiler.err.concrete.inheritance.conflict",
						"{1}のメソッド{0}と{3}の{2}は同じシグニチャから継承されています" },
				{ "compiler.err.const.expr.req", "定数式が必要です" },
				{ "compiler.err.cont.outside.loop", "continueがループの外にあります" },
				{ "compiler.err.cyclic.annotation.element", "注釈の要素タイプがループしています" },
				{ "compiler.err.cyclic.inheritance", "{0}を含む継承がループしています" },
				{ "compiler.err.default.allowed.in.intf.annotation.member",
						"デフォルト値は@interfaceメンバー内でのみ使用できます" },
				{ "compiler.err.diamond.not.supported.in.source",
						"ダイヤモンド演算子は-source {0}でサポートされていません\n(ダイヤモンド演算子を使用可能にするには、-source 7以降を使用してください)" },
				{ "compiler.err.does.not.override.abstract",
						"{0}はabstractでなく、{2}内のabstractメソッド{1}をオーバーライドしません" },
				{ "compiler.err.doesnt.exist", "パッケージ{0}は存在しません" },
				{ "compiler.err.dot.class.expected", "''.class''がありません" },
				{ "compiler.err.duplicate.annotation", "注釈が重複しています" },
				{ "compiler.err.duplicate.annotation.member.value",
						"{1}の注釈メンバーの値{0}が重複しています" },
				{ "compiler.err.duplicate.case.label", "caseラベルが重複しています" },
				{ "compiler.err.duplicate.class", "クラス{0}が重複しています" },
				{ "compiler.err.duplicate.default.label", "defaultラベルが重複しています" },
				{ "compiler.err.else.without.if", "''else''への''if''がありません" },
				{ "compiler.err.empty.char.lit", "空の文字リテラルです" },
				{ "compiler.err.encl.class.required", "{0}を含む囲うインスタンスが必要です" },
				{ "compiler.err.enum.annotation.must.be.enum.constant",
						"列挙型注釈値は、列挙型定数である必要があります" },
				{
						"compiler.err.enum.as.identifier",
						"リリース5から''enum''はキーワードなので識別子として使用することはできません\n(''enum''を識別子として使用するには-source 1.4以前を使用してください)" },
				{ "compiler.err.enum.cant.be.instantiated", "列挙型はインスタンス化できません" },
				{ "compiler.err.enum.label.must.be.unqualified.enum",
						"列挙型のswitch caseラベルは列挙型定数の非修飾名である必要があります" },
				{ "compiler.err.enum.no.finalize",
						"列挙型はfinalizeメソッドを持つことはできません" },
				{ "compiler.err.enum.no.subclassing",
						"クラスは直接java.lang.Enumを拡張できません" },
				{ "compiler.err.enum.types.not.extensible", "列挙型は拡張可能ではありません" },
				{ "compiler.err.enums.must.be.static",
						"列挙型の宣言はstaticコンテキストでのみ使用できます" },
				{ "compiler.err.enums.not.supported.in.source",
						"列挙型は-source {0}でサポートされていません\n(列挙型を使用可能にするには-source 5以降を使用してください)" },
				{ "compiler.err.error", "エラー: " },
				{ "compiler.err.error.reading.file", "{0}の読込みエラーです。{1}" },
				{ "compiler.err.except.already.caught", "例外{0}はすでに捕捉されています" },
				{ "compiler.err.except.never.thrown.in.try",
						"例外{0}は対応するtry文の本体ではスローされません" },
				{ "compiler.err.expected", "{0}がありません" },
				{ "compiler.err.expected2", "{0}または{1}がありません" },
				{ "compiler.err.expected3", "{0}、{1}または{2}がありません" },
				{ "compiler.err.final.parameter.may.not.be.assigned",
						"finalパラメータ{0}に値を代入することはできません" },
				{ "compiler.err.finally.without.try",
						"''finally''への''try''がありません" },
				{ "compiler.err.foreach.not.applicable.to.type",
						"for-eachは式のタイプに使用できません\n期待値: {1}\n検出値: {0}" },
				{
						"compiler.err.foreach.not.supported.in.source",
						"for-eachループは-source {0}でサポートされていません\n(for-eachループを使用可能にするには、-source 5以降を使用してください)" },
				{ "compiler.err.fp.number.too.large", "浮動小数点数が大きすぎます" },
				{ "compiler.err.fp.number.too.small", "浮動小数点数が小さすぎます" },
				{ "compiler.err.generic.array.creation", "汎用配列を作成します" },
				{ "compiler.err.generic.throwable",
						"汎用クラスはjava.lang.Throwableを拡張できません" },
				{ "compiler.err.generics.not.supported.in.source",
						"総称型は-source {0}でサポートされていません\n(総称型を使用可能にするには、-source 5以降を使用してください)" },
				{ "compiler.err.icls.cant.have.static.decl",
						"内部クラス{0}の静的宣言が不正です\n修飾子''static''は定数および変数の宣言でのみ使用できます" },
				{ "compiler.err.illegal.char", "\\{0}は不正な文字です" },
				{ "compiler.err.illegal.char.for.encoding",
						"この文字は、エンコーディング{0}にマップできません" },
				{ "compiler.err.illegal.combination.of.modifiers",
						"修飾子{0}と{1}の組合せは不正です" },
				{ "compiler.err.illegal.enum.static.ref",
						"初期化子からstaticフィールドへの参照が不正です" },
				{ "compiler.err.illegal.esc.char", "エスケープ文字が不正です" },
				{ "compiler.err.illegal.forward.ref", "前方参照が不正です" },
				{ "compiler.err.illegal.generic.type.for.instof",
						"instanceofの総称型が不正です" },
				{ "compiler.err.illegal.initializer.for.type", "{0}の初期化子が不正です" },
				{ "compiler.err.illegal.line.end.in.char.lit", "文字リテラルの行末が不正です" },
				{ "compiler.err.illegal.nonascii.digit", "不正な非ASCII数字です" },
				{ "compiler.err.illegal.qual.not.icls",
						"修飾子が不正です。{0}は内部クラスではありません" },
				{ "compiler.err.illegal.self.ref", "初期化子内の自己参照" },
				{ "compiler.err.illegal.start.of.expr", "式の開始が不正です" },
				{ "compiler.err.illegal.start.of.type", "型の開始が不正です" },
				{ "compiler.err.illegal.underscore", "不正なアンダースコアです" },
				{ "compiler.err.illegal.unicode.esc", "Unicodeエスケープが不正です" },
				{ "compiler.err.import.requires.canonical",
						"インポートには{0}の標準名が必要です" },
				{ "compiler.err.improperly.formed.type.inner.raw.param",
						"型の形式が不適切です。raw型に指定された型引数です" },
				{ "compiler.err.improperly.formed.type.param.missing",
						"型の形式が不適切です。パラメータが不足しています" },
				{ "compiler.err.incomparable.types", "型{0}と{1}は比較できません" },
				{ "compiler.err.initializer.must.be.able.to.complete.normally",
						"初期化子は正常に完了できる必要があります" },
				{ "compiler.err.int.number.too.large", "整数{0}が大きすぎます" },
				{ "compiler.err.internal.error.cant.instantiate",
						"内部エラーです。{0}を{1}で({2})にインスタンス生成できません" },
				{ "compiler.err.intf.annotation.cant.have.type.params",
						"@interfaceが型パラメータを持つことはできません" },
				{ "compiler.err.intf.annotation.member.clash",
						"@interfaceメンバーは{1}のメソッド''{0}''と競合します" },
				{ "compiler.err.intf.annotation.members.cant.have.params",
						"@interfaceメンバーがパラメータを持つことはできません" },
				{ "compiler.err.intf.annotation.members.cant.have.type.params",
						"@interfaceメンバーが型パラメータを持つことはできません" },
				{ "compiler.err.intf.expected.here", "ここにインタフェースが必要です" },
				{ "compiler.err.intf.meth.cant.have.body",
						"インタフェース・メソッドが本体を持つことはできません" },
				{ "compiler.err.intf.not.allowed.here", "ここではインタフェースは許可されません" },
				{ "compiler.err.invalid.annotation.member.type",
						"注釈メンバーの型が不正です" },
				{ "compiler.err.invalid.binary.number",
						"2進数字は少なくとも1桁の2進数を含む必要があります" },
				{ "compiler.err.invalid.hex.number",
						"16進数字は少なくとも1桁の16進数を含む必要があります" },
				{ "compiler.err.invalid.inferred.types", "{0}の推定型が無効です。{1}" },
				{ "compiler.err.invalid.meth.decl.ret.type.req",
						"無効なメソッド宣言です。戻り値の型が必要です。" },
				{ "compiler.err.io.exception", "ソース・ファイルの読取りエラーです: {0}" },
				{ "compiler.err.label.already.in.use", "ラベル{0}はすでに使用されています" },
				{ "compiler.err.limit.code", "コードが大きすぎます" },
				{ "compiler.err.limit.code.too.large.for.try.stmt",
						"try文のコードが大きすぎます" },
				{ "compiler.err.limit.dimensions", "配列型の次元が多すぎます" },
				{ "compiler.err.limit.locals", "ローカル変数が多すぎます" },
				{ "compiler.err.limit.parameters", "パラメータが多すぎます" },
				{ "compiler.err.limit.pool", "定数が多すぎます" },
				{ "compiler.err.limit.pool.in.class", "クラス{0}内の定数が多すぎます" },
				{ "compiler.err.limit.stack", "コードが要求するスタックが多すぎます" },
				{ "compiler.err.limit.string", "定数文字列が長すぎます" },
				{ "compiler.err.limit.string.overflow",
						"文字列\"{0}...\"のUTF8表現が、定数プールに対して長すぎます" },
				{ "compiler.err.local.enum", "列挙型はローカルにできません" },
				{ "compiler.err.local.var.accessed.from.icls.needs.final",
						"ローカル変数{0}は内部クラスからアクセスされます。finalで宣言される必要があります" },
				{ "compiler.err.malformed.fp.lit", "浮動小数点リテラルが不正です" },
				{ "compiler.err.method.does.not.override.superclass",
						"メソッドはスーパータイプのメソッドをオーバーライドまたは実装しません" },
				{ "compiler.err.missing.meth.body.or.decl.abstract",
						"メソッド本体がないか、abstractとして宣言されています" },
				{ "compiler.err.missing.ret.stmt", "return文が指定されていません" },
				{ "compiler.err.missing.ret.val", "戻り値がありません" },
				{ "compiler.err.mod.not.allowed.here", "修飾子{0}をここで使用することはできません" },
				{ "compiler.err.multicatch.not.supported.in.source",
						"複数catch文は-source {0}でサポートされていません\n(複数catch文を使用可能にするには、-source 7以降を使用してください)" },
				{ "compiler.err.multicatch.parameter.may.not.be.assigned",
						"複数catchパラメータ{0}に値を代入することはできません" },
				{ "compiler.err.multicatch.types.must.be.disjoint",
						"複数catch文の代替をサブクラス化によって関連付けることはできません\n代替{0}は代替{1}のサブクラスです" },
				{ "compiler.err.name.clash.same.erasure",
						"名前が競合しています。{0}と{1}は削除後の名前が同じです" },
				{ "compiler.err.name.clash.same.erasure.no.hide",
						"名前が競合しています。{1}の{0}と{3}の{2}はまだ他方を非表示にしていませんが、削除後の名前が同じです" },
				{ "compiler.err.name.clash.same.erasure.no.override",
						"名前が競合しています。{1}の{0}と{3}の{2}はまだ他方をオーバーライドしていませんが、削除後の名前が同じです" },
				{
						"compiler.err.name.clash.same.erasure.no.override.1",
						"名前が競合しています。{1}の{0}のどちらも、他方の最初のメソッドをまだオーバーライドしていませんが、削除後の名前が別のメソッドと同じメソッドを\nオーバーライドします。最初のメソッド: {3}の{2}\n2番目のメソッド: {5}の{4}" },
				{ "compiler.err.name.reserved.for.internal.use",
						"{0}は内部での使用のため予約されています" },
				{ "compiler.err.native.meth.cant.have.body",
						"nativeメソッドが本体を持つことはできません" },
				{ "compiler.err.neither.conditional.subtype",
						"?に対する互換性のない型 : どちらも他方のサブタイプではありません。\n2番目のオペランド : {0}\n3番目のオペランド : {1}" },
				{ "compiler.err.new.not.allowed.in.annotation",
						"''new''は注釈に使用できません" },
				{ "compiler.err.no.annotation.member", "{1}の注釈メンバー{0}がありません" },
				{ "compiler.err.no.encl.instance.of.type.in.scope",
						"型{0}の内部クラスを囲むインスタンスがスコープ内にありません" },
				{ "compiler.err.no.intf.expected.here", "ここにインタフェースは必要ありません" },
				{ "compiler.err.no.match.entry", "{0}は{1}のエントリに適合しません。{2}が必要です" },
				{ "compiler.err.no.superclass", "{0}にはスーパークラスがありません" },
				{ "compiler.err.non-static.cant.be.ref",
						"staticでない{0} {1}をstaticコンテキストから参照することはできません" },
				{ "compiler.err.not.annotation.type", "{0}は注釈型ではありません" },
				{ "compiler.err.not.def.access.class.intf.cant.access",
						"{1}の{0}がアクセスできないクラスまたはインタフェースに定義されています" },
				{ "compiler.err.not.def.public.cant.access",
						"{1}の{0}はpublicではありません。パッケージ外からはアクセスできません" },
				{ "compiler.err.not.encl.class", "{0}は内部クラスを囲みません" },
				{ "compiler.err.not.loop.label", "{0}はループ・ラベルではありません" },
				{ "compiler.err.not.stmt", "文ではありません" },
				{ "compiler.err.not.within.bounds", "型引数{0}は型変数{1}の境界内にありません" },
				{ "compiler.err.operator.cant.be.applied",
						"単項演算子''{0}''のオペランド型{1}が不正です" },
				{ "compiler.err.operator.cant.be.applied.1",
						"二項演算子''{0}''のオペランド型が不正です\n最初の型: {1}\n2番目の型: {2}" },
				{ "compiler.err.orphaned", "{0}には親がありません" },
				{ "compiler.err.override.incompatible.ret",
						"{0}\n戻り値の型{1}は{2}と互換性がありません" },
				{ "compiler.err.override.meth", "{0}\nオーバーライドされたメソッドは{1}です" },
				{ "compiler.err.override.meth.doesnt.throw",
						"{0}\nオーバーライドされたメソッドは{1}をスローしません" },
				{ "compiler.err.override.static", "{0}\nオーバーライドするメソッドがstaticです" },
				{ "compiler.err.override.weaker.access",
						"{0}\n({1})より弱いアクセス権限を割り当てようとしました" },
				{ "compiler.err.pkg.annotations.sb.in.package-info.java",
						"パッケージの注釈はファイルpackage-info.java内にある必要があります" },
				{ "compiler.err.pkg.clashes.with.class.of.same.name",
						"パッケージ{0}は同名のクラスと競合しています" },
				{ "compiler.err.premature.eof", "構文解析中にファイルの終わりに移りました" },
				{ "compiler.err.prob.found.req", "{0}\n期待値: {2}\n検出値:    {1}" },
				{ "compiler.err.prob.found.req.1",
						"{0} {3}\n期待値: {2}\n検出値:    {1}" },
				{ "compiler.err.proc.bad.config.file",
						"サービス構成ファイルが不正であるか、プロセッサ・オブジェクトの構築中に例外がスローされました: {0}" },
				{ "compiler.err.proc.cant.access",
						"{0}にアクセスできません\n{1}\n詳細は次のスタックトレースで調査してください。\n{2}" },
				{ "compiler.err.proc.cant.access.1", "{0}にアクセスできません\n{1}" },
				{ "compiler.err.proc.cant.create.loader",
						"注釈プロセッサのクラス・ローダーを作成できませんでした: {0}" },
				{ "compiler.err.proc.cant.find.class",
						"''{0}''のクラス・ファイルが見つかりませんでした。" },
				{ "compiler.err.proc.messager", "{0}" },
				{
						"compiler.err.proc.no.explicit.annotation.processing.requested",
						"クラス名''{0}''が受け入れられるのは、注釈処理が明示的にリクエストされた場合のみです" },
				{
						"compiler.err.proc.no.service",
						"サービス・ローダー・クラスが見つかりませんでした。\njava.util.ServiceLoaderかsun.misc.Serviceが使用できる必要があります。" },
				{ "compiler.err.proc.processor.bad.option.name",
						"プロセッサ''{1}''によって指定されたオプション名''{0}''が不正です" },
				{ "compiler.err.proc.processor.cant.instantiate",
						"プロセッサ''{0}''のインスタンスをインスタンス化できませんでした" },
				{ "compiler.err.proc.processor.constructor.error",
						"プロセッサ・オブジェクトの構築中に例外がスローされました: {0}" },
				{ "compiler.err.proc.processor.not.found",
						"注釈プロセッサ''{0}''が見つかりません" },
				{ "compiler.err.proc.processor.wrong.type",
						"注釈プロセッサ''{0}''がjavax.annotation.processing.Processorを実装していません" },
				{ "compiler.err.proc.service.problem",
						"プロセッサをロードするためのサービス・ローダーを作成中にエラーが発生しました。" },
				{ "compiler.err.qualified.new.of.static.class",
						"staticクラスのnewが修飾されています" },
				{ "compiler.err.recursive.ctor.invocation", "コンストラクタの呼出しが再帰的です" },
				{ "compiler.err.ref.ambiguous",
						"{0}の参照はあいまいです。{3}の{1} {2}と{6}の{4} {5}が両方適合します" },
				{ "compiler.err.repeated.annotation.target",
						"注釈ターゲットが繰り返されています" },
				{ "compiler.err.repeated.interface", "インタフェースが繰り返されています" },
				{ "compiler.err.repeated.modifier", "修飾子が繰り返されています" },
				{ "compiler.err.report.access", "{0}は{2}で{1}アクセスされます" },
				{ "compiler.err.ret.outside.meth", "メソッドの外のreturn文です" },
				{ "compiler.err.signature.doesnt.match.intf",
						"シグニチャが{0}に適合しません。互換性のないインタフェースです" },
				{ "compiler.err.signature.doesnt.match.supertype",
						"シグニチャが{0}に適合しません。互換性のないスーパータイプです" },
				{ "compiler.err.source.cant.overwrite.input.file",
						"ソースの書込みエラーです。入力ファイル{0}を上書きできません" },
				{ "compiler.err.stack.sim.error",
						"内部エラー: {0}でのスタック・シミュレーション・エラー" },
				{ "compiler.err.static.imp.only.classes.and.interfaces",
						"static importはクラスとインタフェースからのみとなります" },
				{
						"compiler.err.static.import.not.supported.in.source",
						"static import宣言は -source {0}でサポートされていません\n(static import宣言を使用可能にするには、-source 5以降を使用してください)" },
				{ "compiler.err.string.const.req", "定数の文字列式が必要です" },
				{
						"compiler.err.string.switch.not.supported.in.source",
						"switch内の文字列は-source {0}でサポートされていません\n(switch内の文字列を使用可能にするには、-source 7以降を使用してください)" },
				{ "compiler.err.synthetic.name.conflict",
						"シンボル{0}が、{1}でコンパイラが合成したシンボルと競合します" },
				{ "compiler.err.throws.not.allowed.in.intf.annotation",
						"throws節を@interfaceメンバーで使用することはできません" },
				{ "compiler.err.try.resource.may.not.be.assigned",
						"自動クローズ可能なリソース{0}に値を代入することはできません" },
				{
						"compiler.err.try.with.resources.not.supported.in.source",
						"try-with-resourceは-source {0}でサポートされていません\n(try-with-resourceを使用可能にするには、-source 7以降を使用してください)" },
				{ "compiler.err.try.without.catch.finally.or.resource.decls",
						"''try''への''catch''、''finally''またはリソース宣言がありません" },
				{ "compiler.err.try.without.catch.or.finally",
						"''try''への''catch''または''finally''がありません" },
				{ "compiler.err.type.doesnt.take.params", "型{0}はパラメータをとりません" },
				{ "compiler.err.type.found.req",
						"予期しない型\n期待値: {1}\n検出値:    {0}" },
				{ "compiler.err.type.var.cant.be.deref", "型変数から選択できません" },
				{ "compiler.err.type.var.may.not.be.followed.by.other.bounds",
						"この型変数の後ろに他の境界を配置することはできません" },
				{ "compiler.err.type.var.more.than.once",
						"型変数{0}は{1}の戻り値の型で2回以上出現します。インスタンス生成されないままにはできません" },
				{ "compiler.err.type.var.more.than.once.in.result",
						"型変数{0}は{1}の型で2回以上出現します。インスタンス生成されないままにはできません" },
				{ "compiler.err.types.incompatible.diff.ret",
						"型{0}と型{1}の互換性がありません。両方とも{2}を定義していますが、戻り値の型が無関係です" },
				{ "compiler.err.unclosed.char.lit", "文字リテラルが閉じられていません" },
				{ "compiler.err.unclosed.comment", "コメントが閉じられていません" },
				{ "compiler.err.unclosed.str.lit", "文字列リテラルが閉じられていません" },
				{ "compiler.err.undef.label", "ラベル{0}は未定義です" },
				{ "compiler.err.undetermined.type", "{0}の型引数を推定できません" },
				{ "compiler.err.undetermined.type.1",
						"{0}の型引数を推定できません。\n理由: {1}" },
				{ "compiler.err.unexpected.type",
						"予期しない型\n期待値: {0}\n検出値:    {1}" },
				{ "compiler.err.unreachable.stmt", "この文に制御が移ることはありません" },
				{ "compiler.err.unreported.exception.default.constructor",
						"デフォルトのコンストラクタ内に報告されない例外{0}が存在します" },
				{
						"compiler.err.unreported.exception.implicit.close",
						"報告されない例外{0}は、スローするには捕捉または宣言する必要があります\nリソース変数''{1}''でのclose()の暗黙的なコールから例外がスローされました" },
				{ "compiler.err.unreported.exception.need.to.catch.or.throw",
						"例外{0}は報告されません。スローするには、捕捉または宣言する必要があります" },
				{ "compiler.err.unsupported.binary.lit",
						"2進数リテラルは-source {0}でサポートされていません\n(2進数リテラルを使用可能にするには-source 7以降を使用してください)" },
				{ "compiler.err.unsupported.cross.fp.lit",
						"16進浮動小数点リテラルはこのVMではサポートされていません" },
				{ "compiler.err.unsupported.encoding",
						"サポートされていないエンコーディングです: {0}" },
				{
						"compiler.err.unsupported.fp.lit",
						"16進数浮動小数点リテラルは-source {0}でサポートされていません\n(16進数浮動小数点リテラルを使用可能にするには、-source 5以降を使用してください)" },
				{
						"compiler.err.unsupported.underscore.lit",
						"リテラル内のアンダースコアは-source {0}でサポートされていません\n(リテラル内のアンダースコアを使用可能にするには、-source 7以降を使用してください)" },
				{ "compiler.err.var.might.already.be.assigned",
						"変数{0}はすでに代入されている可能性があります" },
				{ "compiler.err.var.might.be.assigned.in.loop",
						"変数{0}はループ内で代入されている可能性があります" },
				{ "compiler.err.var.might.not.have.been.initialized",
						"変数{0}は初期化されていない可能性があります" },
				{ "compiler.err.varargs.and.old.array.syntax",
						"旧式の配列表記法は可変引数パラメータでは使用できません" },
				{ "compiler.err.varargs.invalid.trustme.anno", "{0}注釈が無効です。{1}" },
				{ "compiler.err.varargs.not.supported.in.source",
						"可変引数メソッドは-source {0}でサポートされていません\n(可変引数メソッドを使用可能にするには、-source 5以降を使用してください)" },
				{ "compiler.err.void.not.allowed.here",
						"ここで''void''型を使用することはできません" },
				{ "compiler.err.warnings.and.werror", "警告が見つかり-Werrorが指定されました" },
				{ "compiler.err.wrong.number.type.args", "型引数の数が不正です。{0}個必要です" },
				{
						"compiler.err.wrong.target.for.polymorphic.signature.definition",
						"MethodHandle APIの作成には-target 7ランタイム以上が必要です。現在は-target {0}です" },
				{ "compiler.misc.anonymous.class", "<anonymous {0}>" },
				{ "compiler.misc.arg.length.mismatch", "実引数リストと仮引数リストの長さが異なります" },
				{ "compiler.misc.assignment.from.super-bound",
						"スーパーバウンド型{0}からの代入" },
				{ "compiler.misc.assignment.to.extends-bound", "拡張バウンド型{0}への代入" },
				{ "compiler.misc.bad.class.file.header",
						"クラス・ファイル{0}は不正です\n{1}\n削除するか、クラスパスの正しいサブディレクトリにあるかを確認してください。" },
				{ "compiler.misc.bad.class.signature", "クラス{0}のシグニチャが不正です" },
				{ "compiler.misc.bad.const.pool.tag", "定数プール・タグ{0}が不正です" },
				{ "compiler.misc.bad.const.pool.tag.at",
						"定数プール・タグ{1}での{0}が不正です" },
				{ "compiler.misc.bad.enclosing.class", "{0}の内部クラスが不正です: {1}" },
				{ "compiler.misc.bad.enclosing.method",
						"クラス{0}の囲んでいるメソッド属性が不正です" },
				{ "compiler.misc.bad.runtime.invisible.param.annotations",
						"RuntimeInvisibleParameterAnnotations属性が不正です: {0}" },
				{ "compiler.misc.bad.signature", "シグニチャ{0}が不正です" },
				{ "compiler.misc.bad.source.file.header",
						"ソース・ファイル{0}は不正です\n{1}\n削除するか、ソース・パスの正しいサブディレクトリにあるかを確認してください。" },
				{ "compiler.misc.base.membership", "すべてのベース・クラスがメンバーです" },
				{ "compiler.misc.cant.implement", "{1}の{0}は{3}の{2}を実装できません" },
				{ "compiler.misc.cant.override", "{1}の{0}は{3}の{2}をオーバーライドできません" },
				{ "compiler.misc.captured.type", "CAP#{0}" },
				{ "compiler.misc.ccf.found.later.version",
						"クラス・ファイル{0}に予想外の新バージョンがあります" },
				{ "compiler.misc.ccf.unrecognized.attribute", "{0}は認識されない属性です" },
				{ "compiler.misc.clashes.with", "{1}の{0}は{3}の{2}と競合します" },
				{ "compiler.misc.class.file.not.found", "{0}のクラス・ファイルが見つかりません" },
				{ "compiler.misc.class.file.wrong.class",
						"クラス・ファイル{0}に不正なクラスがあります" },
				{ "compiler.misc.count.error", "エラー{0}個" },
				{ "compiler.misc.count.error.plural", "エラー{0}個" },
				{ "compiler.misc.count.warn", "警告{0}個" },
				{ "compiler.misc.count.warn.plural", "警告{0}個" },
				{ "compiler.misc.diamond", "{0}<>" },
				{ "compiler.misc.diamond.and.anon.class",
						"匿名内部クラスでは''<>''を使用できません" },
				{ "compiler.misc.diamond.and.explicit.params",
						"コンストラクタの明示的な型パラメータでは''<>''を使用できません" },
				{ "compiler.misc.diamond.non.generic",
						"非汎用クラス{0}で''<>''を使用することはできません" },
				{ "compiler.misc.explicit.param.do.not.conform.to.bounds",
						"明示的な型引数{0}は、宣言された境界{1}に適合しません" },
				{ "compiler.misc.fatal.err.cant.close.loader",
						"致命的エラー: 注釈プロセッサのクラス・ローダーを閉じることができません" },
				{ "compiler.misc.fatal.err.cant.locate.ctor",
						"致命的エラー: {0}のコンストラクタを検出できません" },
				{ "compiler.misc.fatal.err.cant.locate.field",
						"致命的エラー: フィールド{0}を検出できません" },
				{ "compiler.misc.fatal.err.cant.locate.meth",
						"致命的エラー: メソッド{0}を検出できません" },
				{ "compiler.misc.fatal.err.no.java.lang",
						"致命的エラー: クラスパスまたはブート・クラスパスでパッケージjava.langを検出できません" },
				{ "compiler.misc.file.does.not.contain.package",
						"ファイルにパッケージ{0}が含まれていません" },
				{ "compiler.misc.file.doesnt.contain.class",
						"ファイルにクラス{0}が含まれていません" },
				{ "compiler.misc.illegal.start.of.class.file",
						"クラス・ファイルの開始が不正です" },
				{ "compiler.misc.inaccessible.varargs.type",
						"仮可変引数要素型{0}は{1} {2}からアクセスできません" },
				{ "compiler.misc.inapplicable.method",
						"{0} {1}.{2}は使用できません\n({3})" },
				{ "compiler.misc.incompatible.types", "互換性のない型" },
				{ "compiler.misc.incompatible.types.1", "互換性のない型。{0}" },
				{ "compiler.misc.incompatible.upper.bounds",
						"推測の変数{0}には、適合しない上限{1}があります" },
				{ "compiler.misc.inconvertible.types", "変換できない型" },
				{ "compiler.misc.infer.arg.length.mismatch",
						"実引数リストと仮引数リストの長さが異なるため、引数からインスタンスを作成できません" },
				{ "compiler.misc.infer.no.conforming.assignment.exists",
						"型変数{0}のインスタンスが存在しないので、引数型{1}は仮パラメータ型{2}に適合しません" },
				{ "compiler.misc.infer.no.conforming.instance.exists",
						"型変数{0}のインスタンスが存在しないので、{1}は{2}に適合しません" },
				{ "compiler.misc.inferred.do.not.conform.to.bounds",
						"推定型は宣言された境界に適合しません\n推定: {0}\n境界: {1}" },
				{ "compiler.misc.intersection.type", "INT#{0}" },
				{ "compiler.misc.kindname.annotation", "@interface" },
				{ "compiler.misc.kindname.class", "クラス" },
				{ "compiler.misc.kindname.constructor", "コンストラクタ" },
				{ "compiler.misc.kindname.enum", "列挙" },
				{ "compiler.misc.kindname.instance.init", "インスタンス初期化子" },
				{ "compiler.misc.kindname.interface", "インタフェース" },
				{ "compiler.misc.kindname.method", "メソッド" },
				{ "compiler.misc.kindname.package", "パッケージ" },
				{ "compiler.misc.kindname.static", "static" },
				{ "compiler.misc.kindname.static.init", "static初期化子" },
				{ "compiler.misc.kindname.type.variable", "型変数" },
				{ "compiler.misc.kindname.type.variable.bound", "型変数の境界" },
				{ "compiler.misc.kindname.value", "値" },
				{ "compiler.misc.kindname.variable", "変数" },
				{ "compiler.misc.location", "{0} {1}" },
				{ "compiler.misc.location.1", "タイプ{2}の{0} {1}" },
				{ "compiler.misc.no.args", "引数がありません" },
				{ "compiler.misc.no.conforming.assignment.exists",
						"実引数{0}はメソッド呼出変換によって{1}に変換できません" },
				{ "compiler.misc.no.unique.maximal.instance.exists",
						"型変数{0}(上限{1})の固有の最大インスタンスが存在しません" },
				{ "compiler.misc.no.unique.minimal.instance.exists",
						"型変数{0}(下限{1})の固有の最小インスタンスが存在しません" },
				{ "compiler.misc.possible.loss.of.precision", "精度が低下している可能性" },
				{ "compiler.misc.resume.abort", "R)再開,A)中止>" },
				{ "compiler.misc.source.unavailable", "(ソースが利用不可)" },
				{ "compiler.misc.token.bad-symbol", "<bad symbol>" },
				{ "compiler.misc.token.character", "<character>" },
				{ "compiler.misc.token.double", "<double>" },
				{ "compiler.misc.token.end-of-input", "<end of input>" },
				{ "compiler.misc.token.float", "<float>" },
				{ "compiler.misc.token.identifier", "<identifier>" },
				{ "compiler.misc.token.integer", "<integer>" },
				{ "compiler.misc.token.long-integer", "<long integer>" },
				{ "compiler.misc.token.string", "<string>" },
				{ "compiler.misc.try.not.applicable.to.type",
						"try-with-resourceは変数型に適用されません" },
				{ "compiler.misc.type.captureof", "{1}のキャプチャ#{0}" },
				{ "compiler.misc.type.captureof.1", "キャプチャ#{0}" },
				{ "compiler.misc.type.none", "<none>" },
				{ "compiler.misc.type.null", "<null>" },
				{ "compiler.misc.type.parameter", "型パラメータ{0}" },
				{ "compiler.misc.type.req.array.or.iterable",
						"配列またはjava.lang.Iterable" },
				{ "compiler.misc.type.req.class", "クラス" },
				{ "compiler.misc.type.req.class.array", "クラスまたは配列" },
				{ "compiler.misc.type.req.exact", "境界のないクラスまたはインタフェース" },
				{ "compiler.misc.type.req.ref", "参照" },
				{ "compiler.misc.type.var", "{0}#{1}" },
				{ "compiler.misc.type.variable.has.undetermined.type",
						"型変数{0}は未定型です" },
				{ "compiler.misc.unable.to.access.file", "ファイル{0}にアクセスできません" },
				{ "compiler.misc.unchecked.assign", "無検査変換" },
				{ "compiler.misc.unchecked.cast.to.type", "無検査キャスト" },
				{ "compiler.misc.unchecked.clash.with",
						"{1}の{0}は{3}の{2}をオーバーライドします" },
				{ "compiler.misc.unchecked.implement", "{1}の{0}は{3}の{2}を実装します" },
				{ "compiler.misc.unchecked.override",
						"{1}の{0}は{3}の{2}をオーバーライドします" },
				{ "compiler.misc.undecl.type.var", "型変数{0}は宣言されていません" },
				{ "compiler.misc.undetermined.type", "未定型" },
				{ "compiler.misc.unicode.str.not.supported",
						"クラス・ファイル内のUnicode文字列はサポートされていません" },
				{ "compiler.misc.unnamed.package", "名前のないパッケージ" },
				{ "compiler.misc.varargs.argument.mismatch",
						"引数型{0}は可変引数要素型{1}に適合しません" },
				{ "compiler.misc.varargs.clash.with",
						"{1}の{0}は{3}の{2}をオーバーライドします" },
				{ "compiler.misc.varargs.implement", "{1}の{0}は{3}の{2}を実装します" },
				{ "compiler.misc.varargs.override",
						"{1}の{0}は{3}の{2}をオーバーライドします" },
				{ "compiler.misc.varargs.trustme.on.non.varargs.meth",
						"メソッド{0}は可変引数メソッドではありません。" },
				{ "compiler.misc.varargs.trustme.on.reifiable.varargs",
						"可変引数要素型{0}はreifiable型です。" },
				{ "compiler.misc.varargs.trustme.on.virtual.varargs",
						"インスタンス・メソッド{0}はfinalではありません。" },
				{ "compiler.misc.verbose.checking.attribution", "[{0}を確認中]" },
				{ "compiler.misc.verbose.classpath", "[クラス・ファイルの検索パス: {0}]" },
				{ "compiler.misc.verbose.loading", "[{0}を読込み中]" },
				{ "compiler.misc.verbose.parsing.done", "[{0}ミリ秒で構文解析完了]" },
				{ "compiler.misc.verbose.parsing.started", "[{0}を構文解析開始]" },
				{ "compiler.misc.verbose.retro", "[{0}を組替え中]" },
				{ "compiler.misc.verbose.retro.with", "\t{0}を{1}で組替え中です" },
				{ "compiler.misc.verbose.retro.with.list",
						"\t{0}を型パラメータ{1}、スーパータイプ{2}、インタフェース{3}で組替え中です" },
				{ "compiler.misc.verbose.sourcepath", "[ソース・ファイルの検索パス: {0}]" },
				{ "compiler.misc.verbose.total", "[合計{0}ミリ秒]" },
				{ "compiler.misc.verbose.wrote.file", "[{0}を書込み完了]" },
				{ "compiler.misc.version.not.available", "(バージョン情報がありません)" },
				{ "compiler.misc.where.captured",
						"{3}のキャプチャからの{0} extends {1} super: {2}" },
				{ "compiler.misc.where.captured.1",
						"{3}のキャプチャからの{0} extends {1}" },
				{ "compiler.misc.where.description.captured", "{0}が新しい型変数の場合:" },
				{ "compiler.misc.where.description.captured.1",
						"{0}が新しい型変数の場合:" },
				{ "compiler.misc.where.description.intersection",
						"{0}がintersection型の場合:" },
				{ "compiler.misc.where.description.intersection.1",
						"{0}がintersection型の場合:" },
				{ "compiler.misc.where.description.typevar", "{0}が型変数の場合:" },
				{ "compiler.misc.where.description.typevar.1", "{0}が型変数の場合:" },
				{ "compiler.misc.where.intersection", "{0} extends {1}" },
				{ "compiler.misc.where.typevar",
						"{2} {3}で宣言されている{0} extends {1}" },
				{ "compiler.misc.where.typevar.1", "{2} {3}で宣言された{0}" },
				{ "compiler.misc.wrong.version",
						"クラス・ファイルのバージョン{0}.{1}は不正です。{2}.{3}である必要があります" },
				{ "compiler.misc.x.print.processor.info",
						"プロセッサ{0}は{1}に一致し、{2}を返します。" },
				{ "compiler.misc.x.print.rounds",
						"往復{0}:\n\t入力ファイル: {1}\n\t注釈: {2}\n\t最後の往復: {3}" },
				{ "compiler.note.deprecated.filename",
						"{0}は推奨されないAPIを使用またはオーバーライドしています。" },
				{ "compiler.note.deprecated.filename.additional",
						"{0}に推奨されないAPIの追加使用またはオーバーライドがあります。" },
				{ "compiler.note.deprecated.plural",
						"一部の入力ファイルは推奨されないAPIを使用またはオーバーライドしています。" },
				{ "compiler.note.deprecated.plural.additional",
						"一部の入力ファイルは推奨されないAPIを追加使用またはオーバーライドしています。" },
				{ "compiler.note.deprecated.recompile",
						"詳細は、-Xlint:deprecationオプションを指定して再コンパイルしてください。" },
				{ "compiler.note.note", "注意:" },
				{ "compiler.note.proc.messager", "{0}" },
				{ "compiler.note.sunapi.filename",
						"{0}は、今後のリリースで削除される可能性がある内部所有のAPIを使用しています。" },
				{ "compiler.note.sunapi.filename.additional",
						"{0}は、今後のリリースで削除される可能性がある追加の内部所有のAPIを使用しています。" },
				{ "compiler.note.sunapi.plural",
						"一部の入力ファイルは、今後のリリースで削除される可能性がある内部所有のAPIを使用しています。" },
				{ "compiler.note.sunapi.plural.additional",
						"一部の入力ファイルは、今後のリリースで削除される可能性がある内部所有のAPIを追加で使用しています。" },
				{ "compiler.note.sunapi.recompile",
						"詳細は、-Xlint:sunapiオプションを指定して再コンパイルしてください。" },
				{ "compiler.note.unchecked.filename",
						"{0}の操作は、未チェックまたは安全ではありません。" },
				{ "compiler.note.unchecked.filename.additional",
						"{0}に未チェックまたは安全ではない操作がさらにあります。" },
				{ "compiler.note.unchecked.plural",
						"入力ファイルの操作のうち、未チェックまたは安全ではないものがあります。" },
				{ "compiler.note.unchecked.plural.additional",
						"入力ファイルの操作のうち、未チェックまたは安全ではないものがさらにあります。" },
				{ "compiler.note.unchecked.recompile",
						"詳細は、-Xlint:uncheckedオプションを指定して再コンパイルしてください。" },
				{ "compiler.warn.annotation.method.not.found",
						"タイプ''{0}''内に注釈メソッド''{1}()''が見つかりません" },
				{ "compiler.warn.annotation.method.not.found.reason",
						"タイプ''{0}''内に注釈メソッド''{1}()''が見つかりません: {2}" },
				{
						"compiler.warn.assert.as.identifier",
						"リリース1.4から''assert''はキーワードなので、識別子として使用することはできません\n(''assert''をキーワードとして使用するには、-source 1.4以降を使用してください)" },
				{
						"compiler.warn.big.major.version",
						"{0}: メジャー・バージョン{1}は、このコンパイラでサポートされている最新のメジャー・バージョン{2}より新しいです。\nコンパイラのアップグレードをお薦めします。" },
				{ "compiler.warn.constant.SVUID",
						"serialVersionUIDはクラス{0}の定数である必要があります" },
				{ "compiler.warn.diamond.redundant.args",
						"新しい式の型引数が重複しています(かわりにダイヤモンド演算子を使用します)。" },
				{ "compiler.warn.diamond.redundant.args.1",
						"新しい式の型引数が重複しています(かわりにダイヤモンド演算子を使用します)。\n明示的: {0}\n推定: {1}" },
				{ "compiler.warn.dir.path.element.not.found",
						"不正なパス要素\"{0}\": そのディレクトリは存在しません" },
				{ "compiler.warn.div.zero", "ゼロで除算" },
				{ "compiler.warn.empty.if", "if以降が空の文です" },
				{
						"compiler.warn.enum.as.identifier",
						"リリース5から''enum''はキーワードなので識別子として使用することはできません\n(''enum''をキーワードとして使用するには-source 5以降を使用してください)" },
				{ "compiler.warn.finally.cannot.complete",
						"finally節が正常に完了できません" },
				{ "compiler.warn.forward.ref", "初期化される前の変数''{0}''を参照しようとしました" },
				{ "compiler.warn.future.attr",
						"バージョン{1}.{2}のクラス・ファイルで導入された{0}属性は、バージョン{3}.{4}のクラス・ファイルでは無視されます" },
				{ "compiler.warn.has.been.deprecated", "{1}の{0}は推奨されません" },
				{ "compiler.warn.illegal.char.for.encoding",
						"この文字は、エンコーディング{0}にマップできません" },
				{ "compiler.warn.improper.SVUID",
						"serialVersionUIDは、クラス{0}にstatic finalを宣言する必要があります" },
				{
						"compiler.warn.inexact.non-varargs.call",
						"最終パラメータの不正確な引数型を持った可変引数メソッドの非可変引数呼出し。\n可変引数呼出しに関しては{0}にキャストします。\n非可変引数呼出しに関しては{1}にキャストしてこの警告を出さないようにします" },
				{ "compiler.warn.invalid.archive.file", "パス上の予期しないファイル: {0}" },
				{ "compiler.warn.lintOption", "[{0}] " },
				{ "compiler.warn.long.SVUID",
						"serialVersionUIDは、クラス{0}のlong型である必要があります" },
				{ "compiler.warn.missing.SVUID",
						"直列化可能なクラス{0}には、serialVersionUIDが定義されていません" },
				{ "compiler.warn.missing.deprecated.annotation",
						"推奨されない項目は@Deprecatedで注釈が付けられていません" },
				{ "compiler.warn.override.bridge",
						"{0}。オーバーライドされたメソッドはブリッジ・メソッドです" },
				{ "compiler.warn.override.unchecked.ret",
						"{0}\n戻り値の型は{1}から{2}への無検査変換が必要です" },
				{ "compiler.warn.override.unchecked.thrown",
						"{0}\nオーバーライドされたメソッドは{1}をスローしません" },
				{ "compiler.warn.override.varargs.extra",
						"{0}。オーバーライドしているメソッドには''...''がありません" },
				{ "compiler.warn.override.varargs.missing",
						"{0}。オーバーライドされたメソッドには''...''がありません" },
				{ "compiler.warn.path.element.not.found",
						"不正なパス要素\"{0}\": そのファイルまたはディレクトリはありません" },
				{ "compiler.warn.pkg-info.already.seen",
						"package-info.javaファイルがすでにパッケージ{0}用に表示されています" },
				{ "compiler.warn.position.overflow",
						"位置エンコーディングが行{0}でオーバーフローします" },
				{ "compiler.warn.possible.fall-through.into.case",
						"caseにfall-throughする可能性があります" },
				{ "compiler.warn.prob.found.req", "{0}\n期待値: {2}\n検出値:    {1}" },
				{ "compiler.warn.proc.annotations.without.processors",
						"これらの注釈を要求するプロセッサはありませんでした: {0}" },
				{ "compiler.warn.proc.file.create.last.round",
						"最後に作成されたタイプ''{0}''のファイルは注釈処理に渡されません。" },
				{ "compiler.warn.proc.file.reopening",
						"''{0}''用のファイルを複数回作成しようとしています" },
				{ "compiler.warn.proc.illegal.file.name",
						"無効な名前''{0}''のファイルは作成できません。" },
				{ "compiler.warn.proc.malformed.supported.string",
						"プロセッサ''{1}''が返したサポートされる注釈型の文字列''{0}''が不正です" },
				{ "compiler.warn.proc.messager", "{0}" },
				{ "compiler.warn.proc.package.does.not.exist",
						"パッケージ{0}は存在しません" },
				{ "compiler.warn.proc.proc-only.requested.no.procs",
						"コンパイルなしの注釈処理がリクエストされましたが、プロセッサが見つかりませんでした。" },
				{ "compiler.warn.proc.processor.incompatible.source.version",
						"注釈プロセッサ''{1}''から-source ''{2}''より小さいソース・バージョン''{0}''がサポートされています" },
				{ "compiler.warn.proc.suspicious.class.name",
						"名前が{1}で終わる型のファイルを作成しています: ''{0}''" },
				{ "compiler.warn.proc.type.already.exists",
						"タイプ''{0}''のファイルはすでにソース・パスまたはクラスパスに存在します" },
				{ "compiler.warn.proc.type.recreate",
						"タイプ''{0}''のファイルを複数回作成しようとしています" },
				{ "compiler.warn.proc.unclosed.type.files",
						"タイプ''{0}''のファイルが閉じられていません。これらのタイプは注釈処理されません" },
				{ "compiler.warn.proc.unmatched.processor.options",
						"次のオプションはどのプロセッサでも認識されませんでした: ''{0}''" },
				{ "compiler.warn.proc.use.implicit",
						"暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-implicitを使用し暗黙的コンパイルのポリシーを指定してください。" },
				{
						"compiler.warn.proc.use.proc.or.implicit",
						"暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-proc:noneを使用し注釈処理を無効にするか -implicitを使用し暗黙的コンパイルのポリシーを指定してください。" },
				{ "compiler.warn.raw.class.use",
						"raw型が見つかりました: {0}\n汎用クラス{1}の型引数がありません" },
				{ "compiler.warn.redundant.cast", "{0}への冗長なキャストです" },
				{ "compiler.warn.self.ref", "初期化子内の変数''{0}''の自己参照" },
				{ "compiler.warn.source.no.bootclasspath",
						"ブートストラップ・クラスパスが-source {0}と一緒に設定されていません" },
				{ "compiler.warn.static.not.qualified.by.type",
						"static {0}は式ではなく型名{1}で修飾する必要があります" },
				{ "compiler.warn.sun.proprietary",
						"{0}は内部所有のAPIであり、今後のリリースで削除される可能性があります" },
				{ "compiler.warn.synthetic.name.conflict",
						"シンボル{0}が、{1}でコンパイラが合成したシンボルと競合します" },
				{ "compiler.warn.try.explicit.close.call",
						"自動クローズ可能なリソースにおけるclose()の明示的呼出し" },
				{ "compiler.warn.try.resource.not.referenced",
						"自動クローズ可能なリソース{0}は対応するtry文の本体では参照されません" },
				{ "compiler.warn.try.resource.throws.interrupted.exc",
						"自動クローズ可能なリソース{0}に、InterruptedExceptionをスローする可能性があるメンバー・メソッドclose()があります" },
				{ "compiler.warn.unchecked.assign", "{0}から{1}への無検査代入です" },
				{ "compiler.warn.unchecked.assign.to.var",
						"raw型{1}のメンバーとして変数{0}への無検査代入です" },
				{ "compiler.warn.unchecked.call.mbr.of.raw.type",
						"raw型{1}のメンバーとしての{0}への無検査呼出しです" },
				{ "compiler.warn.unchecked.cast.to.type", "型{0}への無検査キャストです" },
				{ "compiler.warn.unchecked.generic.array.creation",
						"型{0}の可変引数パラメータに対する総称型配列の無検査作成です" },
				{ "compiler.warn.unchecked.meth.invocation.applied",
						"無検査メソッド呼出し: {4} {5}の{0} {1}は指定された型に適用されます\n期待値: {2}\n検出値: {3}" },
				{ "compiler.warn.unchecked.varargs.non.reifiable.type",
						"パラメータ化された可変引数型{0}からのヒープ汚染の可能性があります" },
				{ "compiler.warn.unexpected.archive.file",
						"アーカイブ・ファイルの予期しない拡張子: {0}" },
				{ "compiler.warn.unknown.enum.constant", "不明な列挙型定数です{1}.{2}" },
				{ "compiler.warn.unknown.enum.constant.reason",
						"不明な列挙型定数です{1}.{2}\n理由: {3}" },
				{ "compiler.warn.unreachable.catch",
						"catch句に移すことができません\nスローされたタイプ{0}はすでに捕捉されています" },
				{ "compiler.warn.unreachable.catch.1",
						"catch句に移すことができません\nスローされたタイプ{0}はすでに捕捉されています" },
				{ "compiler.warn.varargs.redundant.trustme.anno",
						"{0}注釈が冗長です。{1}" },
				{ "compiler.warn.varargs.unsafe.use.varargs.param",
						"可変引数メソッドは、型情報保持可能でない可変引数パラメータ{0}からのヒープ汚染の原因となる可能性があります" },
				{ "compiler.warn.warning", "警告:" } };
	}
}